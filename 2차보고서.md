# Team-Info
| (1) 과제명 | *예산 내 소비에 어려움을 겪는 Z세대를 위한 시계열 예측 AI 기반 맞춤형 절약 챌린지 가계부 서비스* |
|:---  |---  |
| (2) 팀 번호/이름 | 02-탐탐 |
| (3) 구성원 | 김지민(2168010): 리더, 기획, AI, Backend <br> 이서현(2276219): 팀원, 기획, Backend, UX/UI Design, AI <br> 박재현(2276137): 팀원, 기획, Frontend, QA |
| (4) 지도교수 | 심재형 교수 |
| (5) 트랙  | 산학 |
| (6) 과제 키워드 | 소비 습관 개선, 맞춤형 절약 챌린지, 시계열 예측 AI, 프롬프트 엔지니어링 |
| (7) 과제 내용 요약 | Mooney(이하 무니)는 *예산 내 소비에 어려움을 겪는 Z세대를 위한 시계열 예측 AI 기반 맞춤형 절약 챌린지 가계부 서비스이다. 사용자가 스스로 설정한 예산 안에서 지속 가능한 소비 습관을 형성할 수 있도록 기획되었다.* <br> *무니는 자체 개발한 시계열 예측 AI 모델(Prophet 기반)을 통해, 사용자의 소비 패턴을 분석해 매주 과소비가 예측되는 카테고리를 선별하고, 해당 카테고리에 대해  사용자의 기존 행동을 개선하는 소비 절약 챌린지를 제공한다. 챌린지는 사용자가 자주 이용하는 지출처나 고액 지출 항목을 중심으로 구성되며, 일상 속에서 지킬 수 있도록 설계되어 있다.* <br> *무니가 지향하는 ‘절약’은 무조건 지출을 줄이는 것이 아닌, 사용자가 설정한 예산 내에서 소비할 수 있도록 하는 것이다. 즉 예산을 초과하는 과소비 방지를 위해 불필요한 지출을 줄이면서도, 예산 내에서는 자유롭게 소비할 수 있도록 하기 위한 구체적 가이드라인을 제공하고자 한다. 또한 챌린지를 성공적으로 수행할 경우, 경험치, 캐릭터 해금, UI 변화 등 다양한 게이미피케이션 요소를 통해 사용자의 동기를 강화하고, 소비 관리 및 절약 과정을 즐겁게 지속할 수 있도록 유도한다.* <br> *사용자는 소비를 앞두고 고민이 생길 때, ‘똑똑소비봇’(GPT-4o-mini 기반)에 자연어로 질문을 입력할 수 있다. 챗봇은 해당 소비가 속한 카테고리를 판단하고, 해당 카테고리의 예산 잔액, 챌린지 성공률, 향후 소비 예측 등을 종합 분석한다. 이를 통해, 사용자가 원하는 소비가  예산 내에서 가능한 소비인지를 판단하여 조언을 제공한다. 무니가 추구하는 ‘현명한 소비’란 사용자의 소비 욕구를 존중하면서도, 예산을 지키는 소비이며, 챗봇은 이 기준에 따라 균형 잡힌 결정을 함께 설계한다.* <br> *무니는 단순히 지출을 기록하는 앱이 아니라, 사용자 맞춤형 챌린지와 실시간 피드백을 통해 적극적으로 개입하고 상호작용하는 소비 습관 개선 파트너이다. 이를 통해 사용자가 예산 내 소비를 꾸준히 실천하고, 장기적으로 재정적 자립 역량을 키울 수 있도록 돕는 것이 무니 서비스의 궁극적 목표이다.*


<br>

# Project-Summary
| 항목 | 내용 |
|:---  |---  |
| (1) 문제 정의 | **[문제 정의 및 배경]**<br>현대 사회에서 MZ세대는 자율적으로 지출을 결정하는 첫 시기에 놓여 있다. 하지만 많은 이들은 매달 소비 예산을 세우더라도 이를 꾸준히 지키는 데 어려움을 겪고 있으며, 충동구매와 과소비로 인해 '예산 초과 → 스트레스 → 다시 과소비'의 악순환에 빠지기 쉽다. 자체 설문조사에서도 응답자의 74%가 지출 관리에 어려움을 느낀 경험이 있다고 답해, 이러한 문제가 MZ세대 전반에 걸쳐 나타나고 있음을 보여준다. <br>행동경제학자 Richard Thaler와 Shlomo Benartzi의 연구에 따르면, 습관은 자동화되고 고착화되는 경향이 있어 초기 금융 습관이 이후 재정적 의사결정에 장기적인 영향을 미친다고 한다. 이러한 점을 고려할 때, MZ세대가 소비 초기 단계에서부터 올바른 지출 습관을 형성하는 것은 단기적인 예산 관리를 넘어 장기적인 재정 안정성을 위한 핵심적인 출발점이 된다.<br>그러나 기존의 가계부 앱은 단순히 소비 내역을 기록하거나 수치적으로 트래킹하는 데 그쳐, 과소비 방지 등 사용자의 실제 행동 변화를 이끌어내는 데에는 한계가 있다. 이로 인해 소비 관리에 대한 흥미가 떨어지고, 지속적인 소비 습관 개선으로 이어지지 못하는 경우가 많다.<br>이에 본 과제에서는 시계열 AI 예측 모델 기반 솔루션 '무니'를 제안한다. 위 서비스는 개인 소비 데이터를 분석해 과소비가 예상되는 카테고리를 예측하고 해당 카테고리에 맞춤형 소비 절약 챌린지를 제공한다. 또한,  AI 소비 조언 챗봇(이하 똑똑소비봇) 기능을 통해 사용자가 보다 현명한 소비 결정을 내릴 수 있도록 돕는다. 이러한 솔루션은 게이미피케이션 및 캐릭터 시스템과 결합하여  MZ세대가 더 흥미롭고 지속 가능하게 소비를 관리할 수 있도록 한다. <br><br> **[Target Customer]** <br>무니는 소비 습관이 아직 자리 잡히지 않은 MZ세대(20~30대 초반) 중에서도, 지출 관리에 흥미를 느끼지 못하거나 예산 내 소비를 실천하는 데 어려움을 겪는 사람들을 주요 타겟층으로 설정하였다.<br> 이들은 충동구매, 스트레스 소비, 계획 없는 지출 등을 반복하면서도 본인의 소비 습관을 명확히 파악하거나 조절하기 어려워한다. 또한 디지털 친화적이고 게임 요소 및 피드백 기반의 동기부여 방식을 선호하는 MZ세대의 특성을 고려할 때, AI 기반 소비 예측과 캐릭터형 챌린지 시스템을 접목한 무니의 서비스 구조에 높은 수용 가능성을 보인다.<br><br> **[Pain Points]** <br>1. 지출/예산 관리에 흥미를 느끼지 못한다<br>기존의 가계부 앱은 기록과 숫자 중심으로 구성되어 있어 재미와 몰입 요소가 부족하다. 이러한 반복적인 기록형 서비스는, 장기적인 사용 지속이 어렵다. <br><br>2. 충동 소비 및 스트레스 소비를 억제하기 어렵다<br>감정이나 순간적인 상황에 따라 지출을 결정하게 되는 일을 겪는 경우가 많지만, 이를 제어할 만한 실시간 조언이나 제동 장치가 부족하다.<br><br> 3. 본인의 소비 습관을 명확히 인지하기 어렵다<br>자신의 소비 내역을 스스로 분석하거나 패턴을 도출해내기 어렵기에, 자신의 소비 습관 중 문제가 되는 부분이 정확히 어디인지 파악하기가 힘들다.<br><br>4. 소비 습관을 개선할 수 있는 구체적 실천 방안이 없다<br>기존의 가계부 서비스엔 구체적인 실천 방안이 아예 없거나, 있더라도 전체 예산을 n분의 1한 금액을 하루 예산으로 제공하는 등 실효성이 없는 방안이 제시된다. 즉 실제 어떤 항목에서 어떻게 절약해야 하는지에 대한 실행 지침이 부족하다.<br><br>5. 합리적인 예산 설정이 어렵고 복잡하다<br>많은 이들이 계획적인 소비의 중요성에는 공감하지만, 실제로는 예산을 수립하지 않는 경우가 많다. Nielsen 신문의 전국 성인 남녀 10,000명 대상 설문조사에 따르면, 45.5%가 계획적인 소비를 '합리적인 소비'로 인식하는 반면, 59.9%는 한 달 소비 계획조차 세우지 않았다. 자체 설문조사 결과, 예산을 세우지 않는 이유로 52.3%가 '예산 관리 방법을 몰라서'라고 응답했다. 이는 사용자들이 예산 수립의 필요성은 인지하고 있으나, 구체적인 방법을 몰라 실천하지 못하고 있음을 의미한다. 그러나 기존 가계부 서비스는 예산을 어떻게 나누고 조정할지에 대한 실질적인 가이드를 제공하지 않아, 이러한 문제를 해결하지 못하고 있다.<br><br>|
| (2) 기존연구와의 비교 | **[타 가계부 서비스와의 비교]** <br><br> ![image](https://github.com/user-attachments/assets/112b9ddb-972f-48d8-ad73-458b5ab8a4ce)<br> **1. 뱅크샐러드**: 데이터 기반 자산관리 가계부 서비스<br> - 장점: 사용자의 은행 계좌, 카드, 보험, 투자, 대출, 부동산 등 다양한 금융 정보를 연동해 하나의 화면에서 통합적으로 관리할 수 있다. 또한 소비 데이터를 기반으로 월별·주별 소비 패턴을 시각화하여 자신의 지출 흐름과 고비용 항목을 직관적으로 파악할 수 있도록 도와준다.<br> - 단점: 소비가 많았던 항목에 대한 경고 알림은 단순히 수치 기반 알림에 그쳐 실질적인 행동 변화로 이어지기 어려우며, 예산이 이미 부족한 상황에서도 단순히 (남은 예산 / 일 수)로 하루 예산을 제공한다. 이에 사용자에게 생활이 불가능한 수준으로 예산을 제시하여,  실천 가능한 절약 방안을 제공하지 못한다는 한계가 있다.<br>→ 무니의 차별점: 무니는 사용자의 소비 데이터를 기반으로 매주 과소비가 예상되는 카테고리를 선제적으로 예측하고, 해당 카테고리에 대해 구체적인 절약 행동으로 연결되는 소비 챌린지를 자동 생성함으로써, 단순 알림을 넘어선 실천 유도형 소비 관리를 제공한다.<br><br> **2. 똑똑가계부**: 수기 입력 중심의 단순 가계부 서비스<br> - 장점: 앱의 인터페이스가 매우 단순하고 직관적이어서 앱 사용에 익숙하지 않은 사용자도 손쉽게 수입·지출을 기록할 수 있다. 카테고리를 자유롭게 설정할 수 있어 사용자 취향에 맞는 맞춤형 소비 내역 정리가 가능하다.<br> - 단점: 모든 소비 내역을 사용자가 직접 입력해야 하며, 외부 은행/카드사와의 연동이나 자동 인식 기능이 없어 실시간 소비 분석이나 예산 트래킹이 불가능하다. 또한, 소비에 대한 피드백을 제공하는 기능은 따로 없어, 단순한 기록에 그친다.<br>→ 무니의 차별점: 무니는 사용자의 소비 데이터를 AI가 분석해 자동으로 챌린지를 생성하고, 월간 소비 리포트를 제공하며, 똑똑소비봇을 통해 소비 상황에 따른 즉각적인 피드백까지 제공함으로써, 사용자의 개입을 최소화하면서도 효율적이고 지속 가능한 소비 관리를 지원한다.<br><br>3. **토스**: 금융 통합 플랫폼<br> - 장점: 송금, 대출, 보험, 투자 등 다양한 금융 기능을 한 앱에서 통합적으로 제공하며, 간편하고 깔끔한 UI/UX로 누구나 쉽게 접근할 수 있다. 특히 빠른 송금과 실시간 알림 기능은 일상 속 금융 관리에 매우 유용하다.<br> - 단점: 대출, 보험, 투자 등 다양한 금융분야를 포괄하는 어플이긴 하지만 그 중 소비 관리 기능은 단순한 수준에 머물며, '오늘 쓴 금액'이나 '총 지출'만 확인할 수 있고, 카테고리별 예산 설정이나 예산 대비 진행률 분석 등 고도화된 소비 관리 기능이 부족하다.<br>→ 무니의 차별점: 무니는 토스처럼 직관적인 UI/UX를 갖추되, 초기 예산 설정 가이드라인부터 주간 챌린지, 카테고리별 잔액 분석, 월별 소비 리포트까지 소비 관리에 최적화된 전용 기능을 갖춘 플랫폼으로, 사용자가 예산 내 소비 습관을 형성할 수 있도록 돕는 데 초점을 맞춘다.|
| (3) 제안 내용 |  무니는 '예측 기반 맞춤형 소비 절약 챌린지', '예산 사용 현황을 기반으로 소비 판단을 돕는 똑똑소비봇', '게이미피케이션 기반 동기 강화 시스템'이라는 세 가지 솔루션을 제안한다. 이를 통해 사용자는 단순 기록 중심의 가계부에서 벗어나, 무니의 AI 솔루션과 게이미피케이션을 통해 예산 내 소비를 효과적으로 실천할 수 있다.<br><br> **1. 예측 기반 맞춤형 소비 챌린지를 통한 과소비 방지 솔루션**<br>무니는 지출을 기록하는 수준을 넘어, 예산 초과가 예상되는 카테고리에 대해 사용자 맞춤형 소비 절약 챌린지를 제공한다.<br> 자체 개발한 시계열 예측 AI 모델(Prophet 기반)을 통해 사용자의 과거 소비 데이터를 분석하고, 다음 주의 카테고리별 소비 금액을 예측한다. 예측 결과가 해당 카테고리의 주간 예산을 초과할 것으로 판단되는 항목들에 대해 무니는 매주 3개의 챌린지를 자동 생성하여 사용자에게 제시한다.<br>각 챌린지는 카테고리(예: 카페, 외식, 쇼핑 등) 및 자주 사용한 지출처와 함께, 사용자가 실천 가능한 구체적인 절약 행동으로 구성된다.<br>예시:<br>"이번 주 스타벅스 방문 2회 이하로 줄이기"<br>"배달앱 사용 금액 15,000원 이하 유지하기"<br>"의류 쇼핑은 최대 1회로 제한하기"<br>이러한 예측-행동 맞춤형 소비 관리 구조는 사후적 피드백을 넘어, 사용자의 일상 속 실천 가능한 목표 설정을 통한 소비 행동 개선을 가능하게 한다.<br><br>**2. 예산 사용 현황을 기반으로 소비 판단을 돕는 똑똑소비봇 솔루션**<br>소비 결정 전, "이 소비를 지금 해도 될까?", "지금 어느정도까지 소비를 해도 예산 준수에 문제가 없을까?" 라는 사용자의 고민을 해소하기 위해, 무니는 실시간 소비 판단 챗봇 서비스인 '똑똑소비봇'을 제공한다.<br>사용자가 "a는 10,000원이고 b는 30,000원인데 무엇을 사야 할까?" 또는 "이번 주에 이 카페를 또 가도 될까?" 등의 질문을 입력하면, 무니는 다음과 같은 프로세스를 통해 실행 가능한 소비 조언을 제공한다.<br> 1. 입력된 품목이 속한 소비 카테고리를 자동 매칭<br> 2. 해당 카테고리의 남은 예산, 한 달 예산 대비 진행률, 향후 예측 소비 등을 종합 분석<br> 3. 예산을 초과하지 않는 범위 내에서 소비 가능 여부를 자연어로 안내<br>이때 챗봇은 무조건 저렴한 선택지를 제안하는 것이 아닌, 사용자의 욕구와 예산 준수 가능 여부를 균형 있게 고려하여 합리적인 소비 선택의 기준선을 제공한다.<br><br> **3. 지속적 참여를 유도하는 게이미피케이션 기반 동기 강화 시스템**<br>예산 준수를 지루하게 느끼는 사용자, 특히 MZ세대의 행동 변화를 이끌어내기 위해, 무니는 게이미피케이션과 감성적 캐릭터 시스템을 통합한다.<br>- 사용자는 주간 소비 챌린지를 준수할수록 경험치를 획득하며 레벨이 상승함<br> - 일정 레벨에 도달하면 새로운 에이전트 캐릭터(써니, 티타 등)가 해금됨<br> - 각 캐릭터는 고유한 성격, 말투, 피드백 방식(친절/쾌활/냉철/힐링 등)을 가지며, 리포트 및 챗봇에서 사용자와 감정적 연결을 형성<br> 이 시스템은 사용자가 자신의 소비 개선 여정을 하나의 몰입형 게임처럼 느끼게 하여, 장기적인 소비 습관 형성과 앱 지속 이용률 증가에 기여한다.|
| (4) 기대효과 및 의의 | **1. 올바른 소비 습관 형성 지원 (MZ세대 소비 습관 형성)** <br>MZ세대는 아직 소비 습관이 고착되지 않은 시기로, 본 프로젝트는 그들이 예산 범위 내에서 합리적인 소비를 실천함으로써 삶에 장기적으로 긍정적 영향을 줄 합리적인 소비 습관을 형성하도록 돕는다. <br><br> **2. 지속 가능한 소비 관리 습관 형성 (게이미피케이션 기반 동기 부여)** <br> 기존 가계부 앱이 단순히 기록 중심이었다면, 무니는 캐릭터 성장, 배경 변화, 경험치 시스템 등을 도입해 사용자가 소비 관리를 게임처럼 재미있게 지속할 수 있도록 설계되었다.<br> 챌린지 연관 보상 피드백과 레벨업 시스템이 내재적 동기를 유발한다.<br><br> **3. 충동 소비 자제 유도 (AI 소비 조언 기능)** <br>사용자 입력을 기반으로 실시간 예산 상황과 향후 지출을 분석해 감성적인 문장으로 조언을 제공하는 똑똑소비봇은, 충동소비 전 사용자가 한 번 더 고민할 수 있도록 돕는다.<br> 예를 들어 "이번 달 카페 예산은 5천 원 남았어요. 이건 다음 주에 더 쓸 수 있는 여유로 남겨두는 건 어때요?"와 같은 현실적인 피드백을 통해 소비 실천력을 높인다.<br><br> **4. 예방적 소비 관리 기능 (소비 예측 기반 챌린지 제공)** <br>과거 소비 데이터를 바탕으로 다음 주 과소비 가능성이 높은 카테고리를 AI가 예측하고, 해당 카테고리에 대한 사전 대응형 소비 절약 챌린지를 제공한다.  이는 단순히 소비를 기록한 뒤 반성하는 구조에서 벗어나, 과소비를 사전에 방지하는 방식으로 설계되었다.<br><br> **5. 실질적이고 구체적인 절약 방법 제시** <br> "이번 주 스타벅스 방문 3회 이하", "GS25에서 12,000원 이하로 사용하기"와 같은 행동 기반 챌린지를 제시해, 사용자가 막연한 절약이 아닌 구체적이고 실행 가능한 목표를 갖고 소비를 조절할 수 있도록 한다. 이를 통해 목표 달성률을 높이고, 소비 습관 개선을 체감하게 한다.<br><br> **6. 감성형 AI 피드백을 통한 실천 유도** <br>무니의 캐릭터화된 에이전트는 챌린지 피드백, 월간 리포트, 소비 챗봇에서 감정이 담긴 말투와 언어로 피드백을 제공한다.  이는 사용자가 단순 도구로서 앱을 사용하는 것이 아니라, 함께 소비를 고민해주는 '감성적 파트너'와 상호작용하고 있다는 느낌을 주며, 정서적 유대감을 통해 장기적인 사용을 유도한다.|
| (5) 주요 기능 리스트 | 무니의 주요 기능은 총 6가지로 구성되어 있으며, 이들은 기능Ⓐ부터 기능Ⓕ까지로 구분할 수 있다. 각 기능은 **소비 관리, 예산 관리, 게이미피케이션, 사용자 정보 기능**으로 나뉘며, 다음과 같은 내용으로 구성된다.<br><br> **[기능Ⓐ : 맞춤형 소비 챌린지 제공]** <br>  무니는 사용자의 카테고리별 소비 패턴을 분석한 뒤, 과소비가 예측되는 카테고리에 대해 매주 소비 절약 챌린지를 제공한다. 매주 3개의 카테고리에 대해 챌린지가 생성되며, 자주 방문하거나 많은 금액을 사용하는 주요 지출처를 기반으로 구체적인 소비 행동이 제안된다. 예를 들어 "이번 주 스타벅스 3회 이하 방문", "GS편의점에서 12,000원 이하 소비하기"와 같은 실천 중심의 목표가 포함된다.<br><br> **[기능Ⓑ : 똑똣소비봇]** <br> 사용자는 "a는 10,000원이고 b는 30,000원인데 무엇을 사는 게 좋을까?"와 같이 소비 결정을 위한 질문을 챗봇에게 자연어로 입력할 수 있다. 무니의 똑똑소비봇은 질문에 해당하는 소비 카테고리의 예산 잔액과 향후 소비 예측을 바탕으로, 예산을 초과하지 않는 범위 내에서 소비 가능한 적정선을 조언해준다.<br><br> **[기능Ⓒ : 월간 소비 리포트 제공]** <br> 매월 사용자 지출 데이터를 기반으로, 다양한 통계와 지표를 시각적으로 제공하며, AI가 월간 소비 내역을 분석해 자연어로 피드백을 제공한다. 피드백은 '잘한 점', '개선할 점', '예산 준수를 위한 실질적 팁' 등의 항목으로 구성된다.<br><br> **[기능Ⓓ : 첫 예산 수립]** <br> 무니는 예산 설정 경험이 적어 이를 어려워하는 사용자들이, 단계적인 질문을 통해 첫 예산을 쉽게 수립할 수 있도록 돕는다. 사용자의 총 예산, 고정비 항목, 카테고리별 예산 등이 포함된 형태로 구성된다.<br><br> **[기능Ⓔ : 월별/ 일별 소비관리 기능]** <br> 사용자는 월별 또는 일별 소비 내역을 확인할 수 있으며, 카드사 소비 알림 문자나 은행 앱의 푸시 알림을 자동 파싱하여 가계부에 반영할 수 있다. 또한 직접 소비 내역을 입력하거나 수정하는 것도 가능하다. 이번 달의 전체 예산과 카테고리별 예산, 잔액, 진행 현황 등을 상세히 확인할 수 있으며, 예산 항목이나 총 예산 금액을 수정할 수 있다.<br><br> **[기능Ⓕ : 챌린지 기반 동기부여 시스템]** <br> [1] 경험치 및 레벨 :  챌린지를 달성하면 경험치가 누적되며, 일정 경험치에 도달하면 사용자 레벨이 상승한다. 레벨 상승에 따라 새로운 에이전트 캐릭터가 해금되며, 각 캐릭터는 서로 다른 성격과 말투를 가지고 있어 챗봇 대화나 리포트 피드백에서 다채로운 퍼스널리티를 경험할 수 있다. <br> [2] UI 변화형 피드백 : 챌린지의 성공 여부 및 진행률에 따라 앱 UI의 날씨 배경과 이모지가 실시간으로 변화한다. 예를 들어, 챌린지가 잘 수행되고 있을 경우 맑은 날씨 배경과 웃는 이모지, 실패 시 흐린 날씨 배경과 슬픈 이모지가 표시되어 사용자에게 직관적인 피드백을 제공한다.<br>|

# Project-Design & Implementation
| 항목 | 내용 |
|:---  |---  |
| (1) 요구사항 정의 | API 명세서와 ERD(Entity-Relationship Diagram)를 중심으로 요구사항을 정의하였다.<br> 먼저, **API 명세서**는 이름, 도메인, API 요구사항, 클라이언트 처리 로직, Method, URI로 구성되어 있다. 이를 통해 각 API의 응답 형식 뿐만 아니라 클라이언트에서의 처리 로직까지 함께 기술하여, 단순한 api 요청/응답 정의를 넘어 실제 서비스 흐름을 이해할 수 있도록 하였다.<br> 이후 이어지는 **E-R 다이어그램**에서는 전체 기능에서 사용되는 데이터 간의 관계를 시각화하였으며, 이를 통해 서비스 전반의 데이터 구조와 흐름을 한눈에 파악할 수 있도록 구성하였다.<br><br> **1. API 명세서** ![image](https://github.com/user-attachments/assets/ae69fd02-123c-418d-ad38-aea50e507a9f) ![image](https://github.com/user-attachments/assets/9c3fd7e4-dd07-48dc-9bc6-0ee16bc5b49d) ![image](https://github.com/user-attachments/assets/abbfcc5f-3651-4643-a10e-7ad4638c840b) ![image](https://github.com/user-attachments/assets/54d44c2b-6c3d-4a0d-b00c-25659932ae79)<br><br> **2. ERD** <br> ![image](https://github.com/user-attachments/assets/b7f84797-5222-4764-a19c-b5f84112c04f) <br> 각 테이블에 대한 설명은 다음과 같다<br><br> 1. **user_account** 테이블<br>설명: 사용자 계정의 기본 정보를 저장하는 테이블이다. 이메일, 비밀번호, 닉네임, 푸시 알림 설정 등의 정보가 포함된다.<br>주요 필드:<br> - email: 사용자 이메일<br> -encryptedPassword: 암호화된 비밀번호<br>-nickname: 사용자 닉네임<br>- push_alarm_enabled: 푸시 알림 수신 여부<br>- refreshToken: 리프레시 토큰<br><br>2. **agent** 테이블<br>설명: 사용자와 상호작용하는 에이전트 정보를 저장하는 테이블이다. 성격 톤과 말투 스타일 등을 지정할 수 있다.<br>주요 필드:<br>- personality: 성격 유형 (ex. FRIENDLY, HUMOROUS 등)<br>- tone_path: 말투 스타일 경로<br>- agent_name: 에이전트 이름<br><br>3. **agent_prompt** 테이블<br>설명: 캐릭터 agent에 대한 프롬프트 텍스트를 저장하는 테이블이다.<br>주요 필드:<br>- prompt_type: 프롬프트의 유형<br>- prompt_text: 프롬프트의 실제 텍스트<br>- agent_id: 연결된 에이전트 ID<br><br>4. **user_agent** 테이블<br>설명: 사용자가 선택하거나 연동한 에이전트 정보를 저장하는 테이블이다.<br>주요 필드:<br>- tone, personality: 사용자-에이전트 상호작용 스타일<br>- isActive: 현재 사용 중인 에이전트인지 여부<br>- user_id, agent_id: 사용자 및 에이전트와의 연결<br><br>5. **monthly_budget** 테이블<br>설명: 사용자의 월별 예산 정보를 저장한다.<br>주요 필드:<br>- monthDate: 예산이 설정된 월<br>- amount: 해당 월의 전체 예산 금액<br>- user_id: 예산을 설정한 사용자 ID<br><br>6. **category_budget** 테이블<br>설명: 월별 예산 내에서 지출 카테고리별 금액을 저장한다.<br>주요 필드:<br>- amount: 예산 금액<br>- expense_category: 지출 카테고리<br> - monthly_budget_id: 연결된 월별 예산 ID<br><br> 7. **income** 테이블<br>설명: 사용자의 수입 내역을 기록한다.<br>주요 필드:<br>- payer: 수입의 출처<br>- transaction_id: 연결된 거래 ID<br><br>8. **expense** 테이블<br>설명: 사용자의 지출 내역을 기록한다.<br>	주요 필드:<br>- payee: 지출 대상<br>- expense_category: 지출 카테고리<br>- transaction_id: 연결된 거래 ID<br><br>9. **transaction** 테이블<br>설명: 수입 및 지출 내역을 포함한 거래 정보를 저장한다.<br> 주요 필드:<br>- amount: 금액<br>- transaction_type: 거래 유형 (INCOME/EXPENSE)<br>- transaction_source: 거래 출처<br>- note: 거래에 대한 메모<br><br>10. **recurring_transaction** 테이블<br>설명: 고정비(정기 수입/지출)를 기록한다.<br>주요 필드:<br>- title: 거래 제목<br>- cycle: 반복 주기 (ex. 매월)<br>- type: 거래 유형 (EXPENSE/INCOME/SAVINGS)<br><br>11. **scheduled_transaction** 테이블<br>설명: 예약된 거래 정보를 저장한다. 반복 거래와 연결될 수 있다.<br>주요 필드:<br>- transaction_type: 예약 거래 유형<br>- recurring_transaction_id: 연결된 반복 거래 ID<br><br>12. **attendance_record** 테이블<br>설명: 사용자의 출석 기록을 저장한다.<br>주요 필드:<br>- date: 출석 일자<br>- user_id: 사용자 ID<br><br>13. **notification** 테이블<br>설명: 사용자에게 전송된 알림 정보를 저장한다.<br>주요 필드:<br>- notification_type: 알림 유형<br>- content: 알림 내용<br>- isRead: 읽음 여부<br>- user_id: 알림 대상 사용자<br><br>14.**monthly_comment 테이블** <br>설명: 월별 소비에 대한 AI 코멘트를 저장한다.<br>주요 필드:<br>- content: 코멘트 내용<br>- monthly_budget_id: 연결된 예산 ID<br>- user_agent_id: 코멘트를 생성한 AI 에이전트 ID<br><br>15. **chat_room** 테이블<br>설명: 사용자와 AI(똑똑소비봇) 사이의 챗봇 상담 정보를 저장한다.<br>주요 필드:<br>- chat_type: 대화방 유형<br>- user_id, user_agent_id: 사용자 및 에이전트 ID<br><br>16. **chat_message** 테이블<br>설명: 대화방 내 개별 메시지를 저장한다.<br>주요 필드:<br>- sender: 메시지 보낸 주체 (USER 또는 AGENT)<br>- message: 메시지 내용<br>- chat_room_id: 연결된 대화방<br><br>17. **mission** 테이블<br>설명: 사용자에게 제공되는 맞춤형 소비 챌린지 정보를 저장한다.<br>주요 필드:<br>- title: 챌린지 제목<br>- type: 챌린지 유형 (VISIT, EXPENSE)<br>- max_count, max_totalExpense: 달성 조건<br>- category_budget_id: 연결된 카테고리 예산 ID|
| (2) 전체 시스템 구성 | ![Mooney 시스템 아키텍처](https://github.com/user-attachments/assets/aa3775c1-78e1-4993-ab54-53c1533d9da3) <br>Mooney 시스템 아키텍처는 앱 클라이언트, 백엔드 서버, AI 서버 및 시계열 예측 ML 모델, OpenAI API 모듈, DB, 인프라 및 배포 모듈로 이루어져 있다.<br><br>**1. App Frontend 모듈**<br>앱 프론트엔드 모듈은 어플리케이션의 인터페이스를 제공하며, 사용자의 조작에 따라 백엔드 서버에게 요청을 보내고, 응답을 받아 사용자에게 전달한다. 사용자 단말에는 Flutter 기반의 Android 애플리케이션이 설치되어 동작한다. 앱 프론트엔드는 flutter 프레임워크를 사용하여 구현하였으며, 모듈화를 위하여 다음과 같이 세부모듈을 분리하여 설계하였고, 실제 코드의 폴더구조 또한 이를 반영하였다. <br> - UI/사용자 요청(입출력) 처리 모듈<br> - API 통신 모듈 <br> - 결제내역 문자/알림 파싱 모 듈<br>이어서 앱 프론트엔드의 각 세부모듈에 대한 설명을 기술하겠다. <br><br>**1.1 UI/사용자 요청(입출력) 처리 모듈** <br>무니 서비스의 전반적인 화면 구조는 SW 아키텍처 설계도에 기반하여, 홈 화면, 첫 달 예산 수립 화면, 가계부 화면(수입/지출 조회), 예산 화면(예산 조회 및 수정), 분석 화면(소비 분석 및 리포트), 똑똑소비봇 화면, 챌린지 화면, 회원가입/로그인 화면, 프로필 화면(유저 정보 및 설정), 알림 목록 화면 등으로 구성되어 있다. <br> 앱의 각 화면은 팀이 자체적으로 제작한 Figma 디자인을 바탕으로 개발되었으며, Flutter의 위젯 체계를 활용해 재사용성과 유지보수성을 고려한 컴포넌트 구조로 설계되었다. 공통적으로 사용되는 버튼, 입력창, 카드 UI 등은 별도의 공통 위젯으로 분리하였고, 화면별 특화 요소는 상속 또는 파라미터 기반의 설정으로 유연하게 조정되도록 구현하였다. <br> 특히 홈/가계부/똑똑소비봇/챌린지/프로필 화면에 공통으로 사용되는 하단 네비게이션 바는 하나의 재사용 위젯으로 구성하여, 조건에 따라 유동적으로 동작하게 함으로써 코드 중복을 줄이고 화면 간 일관성을 확보하였다. <br> SVG 기반의 캐릭터 및 이모지 리소스는 flutter_svg 라이브러리를 통해 렌더링하여 앱 용량을 최적화하면서도 고해상도 디바이스에 대응할 수 있도록 처리하였다. <br> 분석 화면에서는 사용자의 카테고리별 소비 비율(percent)을 시각적으로 전달하기 위해 fl_chart 라이브러리의 PieChart 위젯을 활용하였다. 각 항목은 색상과 범례를 통해 시각적으로 구분되며, 사용자 입장에서 가장 많이 소비한 항목을 직관적으로 인식할 수 있도록 설계하였다. <br> 마지막으로, 모든 화면은 단순한 디자인 구현을 넘어, 사용자의 입력(예: 버튼 클릭, 텍스트 입력, 챌린지 참여 등)에 따라 내부 상태를 실시간으로 반영하도록 구성되었다. 입력 이벤트에 따라 상태가 변경되면, 해당 상태는 다시 UI 갱신 또는 API 통신과 연결되어 사용자 행동에 즉시 반응하는 사용자 경험을 제공한다. <br> <br> **1.2 API 통신** <br> 무니 앱의 API 통신은 dio 라이브러리를 기반으로 통합 관리되며, 로그인부터 사용자 정보, 챌린지 상태 등 모든 데이터는 RESTful API를 통해 주고받는다. <br>로그인 후 응답으로 받은 액세스 토큰은 flutter_secure_storage를 통해 암호화된 상태로 안전하게 저장하고, 이후 모든 요청에 자동으로 삽입될 수 있도록 인터셉터 로직을 직접 구성하였다. 특히, 요청 시 토큰이 만료된 경우에는 저장된 리프레시 토큰을 통해 액세스 토큰을 자동 재발급받도록 하였다. 재발급에 실패하거나 리프레시 토큰까지 만료된 경우에는 자동으로 로그인 화면으로 이동시키는 흐름을 구현함으로써, 사용자 불편을 최소화하고 보안성을 유지할 수 있는 인증 흐름을 완성하였다. <br> 또한 .env 환경변수 파일을 통해 API Base URL 및 민감 정보를 외부에 노출하지 않도록 설정하고, flutter_dotenv를 통해 이를 앱 내에서 안전하게 불러오도록 구성하였다. 이는 보안뿐 아니라 환경별 설정 분리 및 서버 트래픽 최적화 측면에서도 중요한 설계 고려사항이었다. <br><br> **1.3 챌린지 진행률 기반 UI 그래픽 렌더링 & SVG 전역 상태관리** <br> 홈 화면과 챌린지 화면에 진입할 때, 사용자의 챌린지 진행률(0 ~ 5 사이 실수값)을 API로 받아와 진행 단계별로 다른 이모지 및 배경이 실시간 렌더링되도록 설계하였다. 챌린지 관련 UI는 세부모듈 1.1을 통해 API 응답에 기반한 챌린지 내용 및 진행 현황(예: 챌린지 문구, 진행률 수치 등)을 텍스트로 화면에 렌더링할 뿐만 아니라, 세부모듈 1.3을 통해 해당 진행률 수치를 기준으로 프론트엔드에서 조건 분기 로직을 수행하여 배경 이미지와 캐릭터 이모지를 동적으로 결정하고 렌더링한다. <br> 예를 들어 홈 화면에 표시되는 개별 챌린지 카드에서는 챌린지별 진행 점수에 따라 서로 다른 감정 표현의 이모지가 나타나며, 챌린지 화면에서는 모든 챌린지를 통합한 진행 점수(mooneyStatus)를 기반으로 배경 이미지와 캐릭터 표정이 시각적으로 변화한다. 이러한 구조는 단순 응답 데이터의 출력에서 한 단계 더 나아가, 진행 정도에 따라 사용자의 실천 수준을 직관적이고 감성적으로 전달하는 UI 제공을 목표로 설계된 것이다. <br> 또한 로그인 시점에 서버로부터 현재 활성화된 캐릭터 정보를 받아오고, 앱 전반에서 또한 로그인 시점에 서버로부터 사용자의 현재 활성화된 캐릭터 정보를 한 번만 받아오고, 이를 flutter_riverpod를 활용한 전역 상태로 관리함으로써, 앱 전반에서 캐릭터 SVG가 통일된 형태로 자동 반영되도록 설계하였다. <br> 캐릭터 SVG는 홈 화면, 챌린지 화면, 프로필 등 다양한 위치에서 공통적으로 사용되기 때문에, 이 정보를 전역 상태에 보관해두면 화면마다 반복적으로 API를 호출할 필요 없이 즉시 렌더링이 가능하다. 이러한 구조는 성능 측면에서 효율적일 뿐 아니라, 캐릭터 변경 시 전체 UI에 일관되게 반영되는 사용자 경험을 제공한다. 즉, 한 번의 API 요청으로 여러 화면에 동일한 캐릭터가 동기화되며, 화면 간 데이터 불일치나 중복 호출을 방지할 수 있도록 구현하였다. <br><br> **1.4 문자/금융 앱 알림 내역 확인 및 파싱** <br> 무니는 사용자의 휴대폰에 전송되는 결제내역 문자/은행 앱 알림을 읽어들이는 방식으로 결제내역을 추적/관리한다. 이를 위해 android에서 제공하는 NotificationListenerService 클래스를 이용하여 사용자에게 오는 알림/문자 중 결제내역에 해당하는 것을 읽어들이고, 이를 무니의 API 형식에 맞게 파싱하여 전송한다. 해당 모듈은 프론트엔드의 핵심 모듈이므로, 자세한 구현에 관해선 (3) 주요 모듈 설명 항목에서 자세히 설명한다.  <br><br><br> **2. Backend 서버 모듈**<br> **2.1 핵심 기능 모듈 - 절약 챌린지 시스템** <br> 예측 기반 소비 관리라는 서비스 핵심 가치를 실제 기능으로 구현하기 위해, 절약 챌린지를 자동으로 생성하고 그 진행 상태를 실시간으로 평가·반영하는 시스템을 설계하였다. <br> 맞춤 챌린지 자동 생성 모듈(2.1.1)은 매주 일요일 자정에 Spring Scheduler가 동작하여 사용자의 주간 소비 데이터를 집계하고 AI 서버로 전달한다. AI 서버는 주간 소비 데이터를 바탕으로 카테고리별 다음 주 예측 소비 금액을 반환하며, 이를 기반으로 예산을 초과할 것으로 예상되는 카테고리 중 최대 3개를 선별한다. 이후 해당 카테고리에서 사용자가 자주 소비한 지출처와 자주 방문한 장소 중 일부를 무작위로 선택해, 방문 제한 챌린지와 금액 제한 챌린지를 각각 시뮬레이션한다. 두 챌린지 중 예측 소비와 예산 간 차이를 가장 효과적으로 줄이는 쪽을 최종 챌린지로 선택하며, 자연어 템플릿을 적용해 프론트에 제공할 문장 형태로 변환한다. <br> 챌린지 진행 상태 업데이트 모듈(2.1.2)은 현재 날짜를 기준으로 각 챌린지 목표에 대한 기대 달성률을 계산하고, 실제 소비 내역과 비교하여 실시간 점수를 산출한다. 예를 들어 방문 제한형 챌린지의 경우 현재 방문 수가 기대치보다 적으면 보너스를 주고, 많으면 감점을 적용하며, 예측 소비가 목표를 초과할 것으로 예상되면 추가 감점이 이루어진다. 소비 금액 제한형도 동일한 방식으로 평가되며, 최종 점수는 1.0~5.0 사이로 보정되어 사용자에게 제공된다. <br> 이러한 설계는 소비자의 행동을 주 단위로 점검하고, 실시간 피드백을 제공함으로써 챌린지의 몰입도와 실효성을 높이는 데 목적이 있다. 또한, 단순 금액 비교가 아닌 예측 기반의 실시간 분석 및 평가 시스템이라는 점에서 AI 예측 모델과의 정합성도 고려하였다. <br><br> **2.2 똑똑소비봇 모듈** <br> 사용자가 예산을 초과하지 않고 최적의 소비를 하도록 돕는 똑똑소비봇 모듈을 설계하였다. 똑똑소비봇 모듈은 기능 구현을 위해 다음과 같이 다른 모듈들과 상호작용한다. <br> - PostgreSQL DB에서 사용자, 예산, 지출, 캐릭터 등 데이터를 조회한다. <br> - OpenAI API에 전송하여 GPT가 생성한 응답을 받는다. <br> - Redis DB에 채팅 데이터를 저장한다. <br><br> **2.3 월별리포트 모듈** <br> 사용자의 예산 대비 소비 데이터를 바탕으로, 긍정적인 소비 습관과 개선이 필요한 항목을 분석하고 이를 캐릭터의 성격과 말투에 맞춘 자연어 리포트 형태로 제공하도록 구성하였다. 사용자의 캐릭터 이름, 성격, 어조 및 OpenAI 옵션값(temperature, topP 등), 예산 대비 지출 현황을 입력으로 받아, 우선적으로 예산을 잘 준수한 소비 항목 중 절약 비율이 낮고 지출 금액이 높은 항목을 기준으로 칭찬할 항목 2개를 도출한다. 반대로, 예산을 초과한 소비 항목 중 초과 비율이 높고 초과 금액이 큰 항목을 기준으로 개선이 필요한 항목 2개를 선별한다. 각 항목에 대해 GPT-4o-mini를 활용하여 캐릭터의 말투와 성격에 맞춘 피드백 문장을 생성하고, 다음 달을 위한 실천 전략도 함께 제공한다. 예를 들어, 긍정 피드백에는 칭찬 문구와 유지 전략이 포함되고, 개선 피드백에는 과소비 원인 추정과 실현 가능한 개선 방안이 제시된다. <br> 이를 통해 사용자는 단순한 수치 정보가 아닌, 자신만의 캐릭터가 분석한 인사이트를 자연스러운 대화 형식으로 받아볼 수 있으며, 예산 관리에 대한 몰입도를 높일 수 있다. 설계 전반에는 사용자 동기 부여, 캐릭터 기반 몰입도 향상, OpenAI API의 정교한 활용이라는 세 가지 요소를 균형 있게 반영하였다. <br><br> **2.4 전체 서비스 API 제공** <br> 전체 서비스 기능의 동작을 위한 REST API들을 제공한다. <br> - 사용자 및 보안 도메인 API, 수입/지출 도메인 API, 예산 도메인 API, 분석 도메인 API,  똑똑소비봇 도메인 API, 챌린지 도메인 API, 캐릭터 도메인 API, 알림 도메인 API<br><br><br> **3. 모듈3 – AI 서버 (Python 기반 Prophet 모델)** <br> **3.1 소비 예측 모델** <br> 사용자 맞춤형 소비 챌린지를 제공하기 위한 핵심 기술로서, Prophet 기반 시계열 예측 모델을 Python으로 구현하였다. <br> 사용자별 카테고리 소비 데이터를 주 단위로 12주간 집계하여 입력으로 받고, Pandas 기반의 전처리 과정을 거친 후 Prophet 모델에 적용된다. 이때, 카테고리별로 예측 가능성이 높은 항목만을 자동으로 필터링하기 위해 최근 기록의 연속성, 표준편차, 변동성 기준을 활용한 정제 로직을 구성하였다. <br> 예측 안정성을 높이기 위해 Z-score, IQR, 이동 평균 기반의 이상치 제거를 수행하며, Prophet의 기본 출력값인 yhat 대신 후처리된 yhat_adjusted를 최종 예측 결과로 사용한다. <br> 이 모델은 사용자의 다음 주 소비 금액을 예측하여, 예산 초과가 예상되는 카테고리를 선별하고 챌린지 대상 및 유형을 결정하는 데 활용된다. 예측 결과는 각 챌리지가 소비를 얼마나 줄일 수 있을지를 사전에 시뮬레이션하는 데도 사용된다. 실제 테스트는 사용자별로 48주간의 소비 데이터를 4구간으로 나누어, 각 구간의 앞 11주 데이터를 학습한 뒤 12번째 주의 소비를 예측하는 방식으로 진행되었으며, 예측값과 실제값을 비교해 약 90% 수준의 정확도를 확인하였다. 이처럼 예측 신뢰도는 챌린지 추천과 사용자 피드백의 타당성을 높이는 핵심 기반으로 작용한다. <br><br> **4. OpenAI API 모듈** <br> OpenAI API 모듈은 LLM 모델의 자연어 생성 및 추론 능력을 바탕으로 더욱 맞춤화된 피드백을 제공하기 위해 도입되었다. 백엔드 서버가 Spring AI를 활용해 OpenAI API에 메시지 및 파라미터값을 담아 API 요청을 전송하면, GPT-4o-mini 모델이 응답 메시지를 생성하고 API 응답으로 반환한다. 똑똑소비봇 모듈과 월별 리포트 모듈에서 사용되며, 카테고리가 파악되지 않은 지출처의 카테고리를 추론하기 위해서도 사용된다. <br><br> **5.데이터베이스 모듈** <br> **5.1 PostgreSQL DB** <br> 서비스 데이터 저장을 위해 RDBMS인 PostgreSQL을 사용했다. <br><br> **5.2 Redis** <br> 채팅 내역 저장과 데이터 캐싱을 위해 키-값 데이터베이스인 Redis를 사용했다. Spring Boot 서버와 동일한 EC2의 6379포트에서 실행된다. <br><br> **6.클라우드 및 인프라 모듈** <br> **6.1 AWS 서비스 (EC2, RDS, nginx)** <br> 클라우드 기반 운영을 위해 AWS를 사용한다. 백엔드 서버와 AI 서버가 EC2 위에서 구동되고, 데이터베이스는 RDS에서 안정적으로 운영된다. 서버의 리버스 프록시, SSL Termination 설정을 위해 nginx를 사용한다. <br><br> **6.2 CI/CD 관련 모듈 (Docker, GitHub Actions)** <br> 서버 및 모듈들을 컨테이너 기반으로 운영하기 위해 Docker를 사용한다. GitHub Actions에서 workflow를 작성해 재배포 과정을 자동화했다. <br> |
| (3) 주요엔진 및 기능 설계 | 이 항목에서는 앞서 설명한 프로젝트 전체 구조에 기반하여 구분된 모듈1(App Frontend), 모듈2(Backend), 모듈3(AI), 모듈 4(OpenAI API) 각각의 **구현 내용 및 방법**에 대해 기술한다. 각 모듈이 구현하는 주요 엔진 및 기능에 대해 설명하며, 각 모듈은 **Input, 내부 로직, Output의 관점**에서 설명된다.<br><br> **1. 모듈1 – App Frontend (Flutter 기반)** <br><br> **[서브모듈 1.1 : UI/사용자 요청(입출력) 처리 모듈]** <br> 무니 앱의 화면(UI)은 사용자 요청 처리 방식의 차이에 따라 다음의 두 유형으로 나눌 수 있다. <br> 첫 번째 유형은, 사용자의 요청을 받은 뒤 곧바로 백엔드 API로 전달하고, 응답값을 받아 UI에 렌더링하는 단순 처리 구조를 갖는 화면들이다. 예를 들어 홈, 가계부, 분석, 챌린지, 예산(조회), 로그인 화면은 모두 서버로부터 데이터를 받아 화면에 표시하는 것이 핵심이며, 사용자 입력이나 조건 분기보다는 조회 중심의 단방향 흐름을 가진다. <br> 두 번째 유형은, 사용자의 요청이나 입력에 대해 앱 프론트엔드에서 먼저 자체적으로 로직 처리를 수행한 뒤 서버와 통신하는 구조이다. 첫 달 예산 수립, 예산(수정), 똑똑소비봇, 회원가입 화면 등이 이에 해당하며, 이들 화면에서는 사용자 입력값의 실시간 계산, 유효성 검증, 조건 분기 등 다양한 로직이 프론트 측에서 수행된다. <br> 두 유형 모두 Flutter의 구조적 설계를 반영하여, 화면을 screen, UI 구성 요소를 widget, API 요청/내부 처리 로직을 service, 데이터 구조를 model로 분리하여 관리하고 있다. <br> 다만, 전자는 API 응답 기반의 UI 렌더링이 중심이 되고, 후자는 사용자 요청을 처리하는 프론트엔드 로직의 흐름 설계가 중심이라는 점에서 구현 방식의 초점이 달라진다. <br> 이러한 구분에 따라, 각 유형의 모듈 구현에 대해 서술하겠다. <br><br> **서브모듈 1.1.1 API 응답 기반 화면  (홈, 가계부, 분석, 챌린지, 예산[조회], 로그인,똑똑소비봇)** <br> **Input** <br> - 홈 화면: 사용자가 하단 내비게이션 바에서 홈을 선택하거나, 로그인 성공 시 자동 진입 <br> - 가계부 화면: 사용자가 하단 내비게이션 바에서 가계부를 선택  <br> - 분석 화면: 가계부 화면 상단바에서 분석 탭 선택 <br> - 챌린지 화면: 하단 내비게이션 바에서 챌린지 선택 <br> - 예산 조회 화면: 가계부 화면에서 상단바 예산 탭 선택 <br> - 로그인 화면: 사용자가 로그인 화면에 진입한 뒤, 아이디/비밀번호 입력 후 완료 버튼 클릭 <br> - 똑똑소비봇 화면: 사용자가 똑똑소비봇 화면에 진입(하단바에서 선택) -> 자연어 입력을 통해 소비 고민 메시지를 작성하여 전송버튼 클릭 (예: "A는 10,000원이고 B는 50,000원인데 B를 사도 될까?") <br><br> **내부 로직**  <br> 해당 유형의 화면들은 모두 사용자 요청에 따라 백엔드로부터 데이터를 받아 UI에 렌더링하는 구조를 따른다. 이를 위해 모든 ui 구현의 로직은 `screen`, `widget`, `service`, `model` 단위로 구조적으로 분리되어 있다. <br> - `screen`: 전체 화면의 레이아웃과 흐름을 담당하며, 내부적으로 다양한 위젯을 호출하여 구성 <br> - `widget`: 버튼, 카드, 리스트 등 반복적 UI 요소를 분리한 컴포넌트 단위 <br> - `service`: 각 화면에서 필요한 API 호출 및 응답 처리 담당 <br> - `model`: 응답받은 데이터를 앱 내부에서 사용할 수 있도록 가공하고 구조화 <br><br> 이러한 모듈 단위 분리를 통해, 화면 간 공통 로직 재사용, 유지보수 용이성, 로직 책임 분산 등의 장점을 확보하였다. <br><br> 실제 처리 순서는 다음과 같다. <br> 1. 사용자가 화면에 진입하거나 버튼을 클릭하는 등 특정 액션을 수행하면, 해당 요청에 필요한 정보를 바탕으로 API 호출을 수행한다.<br> 2. 요청에는 사용자 토큰 및 필요한 파라미터가 포함되며, 응답 결과는 `model` 형태로 구조화되어 수신된다. <br> 3. 수신된 데이터는 상태값으로 앱에 반영되며, 해당 값을 구독 중인 위젯들에 자동으로 전달된다. <br>  4. `screen` 내에서는 이 상태값을 기반으로 각 위젯을 호출 및 배치하고, 최종적으로 사용자가 보는 UI를 렌더링한다. 렌더링 시점에서는 상태값 변경 감지에 따라 각 위젯에 반영되어 UI가 자동 업데이트된다. <br><br> **Output** <br> 홈 화면 <br> - 사용자의 닉네임이 포함된 인사말 표시 <br> - 이번 주 진행 중인 챌린지 정보 출력 <br> - 오늘의 지출 총합 카드 표시 <br> - 최근 지출 내역 리스트 표시 <br> - 이번 주 예산 현황 및 잔액 시각화 <br><br> 가계부 화면 <br> - 캘린더에 해당 월 전체 수입/지출액 표시 <br> - 날짜별 거래 기록을 캘린더 하단에 리스트로 표시 <br> - 특정 날짜 선택 시 해당일의 상세 지출/수입 내역 표시 <br> - 좌우 화살표 클릭 시 이전/다음 달의 데이터 조회 가능 <br><br> 분석 화면 <br> - 사용자의 지출 데이터를 기반으로 카테고리별 파이 차트 표시 <br> - 카테고리별 총 사용 금액, 사용 비율 등 시각적 요소 렌더링 <br> - 가장 지출이 많은 항목과 소비 패턴 등 간단한 인사이트 제공 <br><br> 챌린지 화면 <br> - 현재 진행 중인 챌린지 리스트 표시 : 챌린지 제목, 제안 내용 <br> - 해당 챌린지 관련 소비 발생 횟수/금액 <br><br> 예산(조회) 화면 <br> - 이번 달 예산 잔액, 하루 예산, 고정비 지출, 누적 지출 등 항목 표시 <br> - 예산 대비 지출 퍼센트를 막대바로 시각화 <br> - 카테고리별 예산 사용액 리스트로 출력 (예: 식비 30,000원 중 24,000원 사용 등) <br><br> 로그인 화면 <br> - 로그인 실패 시 에러 메시지 표시 (아이디 또는 비밀번호 불일치 등) <br> - 로그인 성공 시 홈 화면으로 자동 이동 <br><br> 똑똑소비봇 화면 <br> - 사용자의 자연어 질문에 대해 백엔드 AI가 생성한 소비 조언 메시지 문자열 출력 <br> - 이전 대화 흐름과 함께 소비봇의 응답이 채팅 UI 형태로 렌더링됨 <br><br> **서브모듈 1.1.2 프론트 자체 처리 로직 기반 화면 (첫 달 예산 수립, 예산[수정],  회원가입)** <br> 이 유형의 화면들은 공통적으로 사용자의 입력 또는 선택에 따라 백엔드와의 통신 이전에 **프론트엔드에서 계산·검증·상태 변경 등의 로직을 자체적으로 수행**한다. 이를 통해 즉각적인 피드백을 제공하거나 조건을 만족하는 경우에만 API를 호출하도록 제어하는 구조이다. <br> 이러한 화면들 또한 기본적으로 (1) 유형의 ui들과 같이  `screen`, `widget`, `service`, `model` 구조를 따른다. 단, `screen`에서 `widget`을 호출해 UI를 구성하는 흐름은 동일하지만, 그 사이에 사용자의 입력값을 실시간으로 처리하는 **프론트엔드 내부 로직이 중심적으로 작동**한다는 점이 이 유형의 핵심적인 특징이다. <br> 아래에서는 각 화면별 프론트 처리 로직의 구조와 흐름을 구체적으로 설명한다. <br><br> **서브모듈 1.1.2-(1) 첫 달 예산 수립** <br> **Input**  <br> 1. 사용자가 입력하는 고정비 항목: 고정 수입, 고정 지출, 고정 저축 항목 각각에 대해 항목 이름, 금액, 주기(예: 월 1회 등) 입력 <br> 2. 고정비 항목 입력 후, 총 예산 입력 <br> 3. 이후 카테고리별 예산 분배 항목에서 사용자 선택에 따라 각 카테고리에 배정할 예산 금액 입력 <br><br> **내부 로직** <br> 1. **고정비 입력 단계** - 사용자는 항목 이름, 금액, 주기 정보를 입력 <br> - 각 항목은 `{title, amount, cycle}` 형식의 데이터로 프론트엔드 상태에 저장됨 <br> - 고정 수입, 지출, 저축의 총합은 실시간으로 계산되어 요약 표시됨 <br><br> 2. **총 예산 입력 단계** - 총 예산 입력 후, 고정비 총합과 비교하여 유효성 검사 <br> - 총 예산이 고정비보다 작을 경우 다음 단계로 진행 불가하며 경고 표시 <br> - 유효한 경우, 카테고리 예산 분배 컴포넌트가 활성화됨 <br><br> 3. **카테고리별 예산 분배 단계** - 총 예산에서 고정비를 뺀 값과 현재까지 배정된 카테고리 예산 총합을 비교 <br> - "남은 예산"을 실시간으로 계산해 상단에 시각적으로 표시 <br> - 사용자가 카테고리별 예산 항목을 선택할 때마다 상태가 갱신되어 UI 반영 <br><br> 4. **최종 제출** - 사용자가 완료 버튼을 누르면 전체 예산 정보를 객체로 정리해 백엔드 API에 전송 <br> - 이 시점까지 모든 계산, 검증, 상태 처리 로직은 프론트엔드에서 수행됨 <br><br> **Output** <br> - 백엔드로 전송되는 첫 달 예산 수립 정보 객체 (상세 구조는 첨부 이미지 참고) <br> ![image](https://github.com/user-attachments/assets/a7b6fe56-7f5b-4dd0-9ce7-ea9784f7e69a) <br><br> **서브모듈 1.1.2-(2) 예산 수정** <br> **Input** <br> - 사용자가 예산 화면 상단에서 "편집" 버튼 클릭 → 예산 편집 화면으로 진입 <br> - 총 예산, 고정비, 카테고리별 예산 항목을 각각 수정 가능 <br> - 각 항목은 개별 입력창을 터치하여 금액 직접 입력 <br><br> **내부 로직** <br> 1. **초기 데이터 로드** - API 응답으로부터 기존 예산 정보를 불러와 각 항목별 입력창에 렌더링 <br> - 각 항목은 `{title, amount}` 형식으로 상태에 저장됨 <br> 2. **실시간 배정 가능 예산 계산** - 사용자가 총 예산 또는 각 카테고리 금액을 수정할 때마다 `(총 예산 – 현재까지 배정된 카테고리 금액)` 값을 실시간으로 계산 <br> - 남은 예산이 UI 상단에 즉시 반영되며, 0원 미만이 되지 않도록 입력값 제한 및 경고 처리 <br> 3. **완료 가능 여부 판단** - 남은 예산이 0 이상일 경우에만 완료 버튼 활성화 <br> - 실시간 유효성 검사를 통해 조건 충족 여부에 따라 UI 상태 자동 조정 <br> 4. **최종 제출** - 수정 완료 후 완료 버튼 클릭 시, 수정된 예산 정보를 하나의 JSON 객체로 정리해 백엔드 API에 전송 <br><br> **Output** <br> - 총 예산, 고정비, 카테고리별 예산이 포함된 수정된 예산 정보 객체가 백엔드에 전송됨 <br><br> **서브모듈 1.1.2-(3) 회원 가입** <br><br>  **Input** <br> - 사용자가 이메일, 비밀번호, 비밀번호 확인, 이름 입력 필드에 각각 텍스트 입력 <br> - 모든 입력값이 유효한 경우에만 “가입하기” 버튼 클릭 가능 <br><br> **내부 로직** <br> 1. **이메일 유효성 확인** - 사용자가 이메일을 입력하고, 마지막 입력 후 2초 이상 타이핑이 없을 경우 “입력 완료”로 간주 <br> - 해당 이메일 주소를 백엔드에 전송하여 사용 가능한 이메일인지 확인 <br> - 응답 결과를 이메일 입력 칸 하단에 메시지로 표시 (예: "사용 가능한 이메일입니다." / "이미 사용 중인 이메일입니다.") <br> 2. **비밀번호 유효성 검사** - 비밀번호는 8 ~ 20자 사이일 경우에만 유효 처리 <br> - 조건에 맞지 않으면 입력 칸 하단에 에러 메시지 표시 (예: "8~20자 사이로 입력해주세요.") <br> 3. **비밀번호 확인 일치 검사** - 비밀번호와 비밀번호 확인란의 입력값이 일치하는지 비교 <br> - 불일치 시 하단에 경고 메시지 표시 (예: "비밀번호가 일치하지 않습니다.") <br> 4. **이름 유효성 검사** - 이름은 1 ~ 10자 사이일 경우에만 유효 <br> - 조건에 맞지 않으면 하단에 메시지 표시 (예: "1 ~ 10자의 이름을 입력해주세요.") <br> 5. **가입 버튼 활성화 조건** - 위 4개 항목 모두 유효할 경우에만 “가입하기” 버튼 활성화 <br>- 유효성 상태는 위의 프론트엔드 자체 로직으로 실시간 판단 <br><br> ***Output*** <br> - 모든 필드가 유효한 경우 “가입하기” 버튼이 활성화됨 <br> - 유효성에 맞지 않는 항목이 있을 경우, 즉시 해당 입력란 아래에 오류 메시지가 표시됨 <br> - 활성화된 가입하기 버튼 클릭 시 API 호출로 회원가입 요청 전송 <br><br> **[서브모듈 1.2 : API 통신]** <br>**Input** <br> - 사용자가 화면에 진입하거나 버튼 클릭 등 특정 액션을 수행하면 해당 요청에 대응하는 API 통신이 발생한다. <br> - 예를 들어, 홈 화면 진입 시 챌린지 정보 요청, 예산 화면 진입 시 예산 데이터 요청 등이 이에 해당한다. <br><br> **내부 로직** <br> - 무니 앱은 `apiClient`라는 전역 API 클라이언트를 중심으로 모든 API 통신을 수행한다. 이 클라이언트는 Dio 기반으로 구성되며, 다음과 같은 특징을 갖는다. <br> - `.env` 파일에서 불러온 BASE_URL을 기본 URL로 사용하며, 모든 요청에 필요한 토큰을 자동으로 첨부하는 구조이다. <br> - 토큰 관리는 `flutter_secure_storage`를 통해 이루어진다. API 호출 시 access token을 안전하게 읽어 Authorization 헤더에 자동 삽입된다. <br> - access token이 만료된 경우에는 저장된 refresh token을 사용해 새로운 access token을 자동으로 발급받는다. <br> - refresh token까지 만료된 경우에는 로그인 화면으로 자동 리다이렉트되도록 예외 처리 흐름이 구현되어 있다. <br> 하단에 ApiClient 코드를 첨부하였다. <br><br> ![스크린샷 2025-05-04 142553](https://github.com/user-attachments/assets/83af644b-6fdc-4590-a957-410dd472403a) <br> ![스크린샷 2025-05-04 142622](https://github.com/user-attachments/assets/5d8e5d1a-c415-41bf-939f-5a10499fe68a) <br><br>  이러한 전역 클라이언트를 기반으로, 각 화면의 service 계층에서는 별도로 토큰을 관리하거나 에러 처리를 반복할 필요 없이, 일관된 방식으로 API 통신을 수행할 수 있다. <br> 실제로는 각 화면의 Service 클래스 내부에서 `apiClient.dio.get(...)`, `post(...)` 등의 방식으로 호출된다. 예시로 서비스코드 중 한 코드를 첨부하였다. <br><br> ![스크린샷 2025-05-04 142846](https://github.com/user-attachments/assets/461a2fa3-2c8f-42af-847b-f4ec80a710d8) <br> 이러한 구조는 인증 토큰 처리의 일관성과 유지보수성을 높이는 동시에, 보안성과 사용자 편의성을 함께 고려한 설계이다. <br><br> **Output** <br> 각 API 요청에 대한 응답 결과는 JSON 형태의 객체로 반환되며, 이후 화면별 서비스 로직에서 파싱되어 사용된다.<br> 예시: <br> - 홈 화면 요청 시: 주간 챌린지 상태를 포함한 JSON 응답 <br> - 예산 화면 요청 시: 예산 항목 리스트, 고정비 정보 등을 포함한 JSON 응답 <br>  - 로그인 시: access token, refresh token 등이 포함된 인증 응답 JSON <br><br>  **[서브모듈 1-3 : 맞춤형 소비 챌린지 UI 제공]** <br><br> **Input** <br> - 사용자가 홈 화면 또는 챌린지 화면에 진입함 <br> -로그인 시, 사용자의 활성 캐릭터 정보가 서버로부터 반환됨 <br><br> **내부 로직** <br> 이 모듈은 단순히 백엔드로부터 수신된 값을 UI에 렌더링하는 구조가 아닌, 응답값(챌린지 점수 등)을 기준으로 프론트엔드에서 조건 분기를 수행하고, 그에 따라 디자인 요소(SVG, 배경 이미지 등)를 다르게 렌더링하는 방식으로 동작한다. <br><br> **1) 홈 화면 내 챌린지 이모지 렌더링** <br> - 홈 화면에서는 사용자에게 제시된 세 개의 주간 챌린지 각각에 대해 개별 진행 점수를 수신한다. <br> - 각 챌린지 점수(result)는 아래와 같은 조건 분기를 통해 상태(status)로 변환된다. <br> &emsp; - 0 이상 2.5 미만: status = 1 <br> &emsp; - 2.5 이상 4.0 미만: status = 2 <br> &emsp; - 4.0 이상: status = 3 <br> - 이 상태값에 따라 각 챌린지에 표시될 캐릭터 이모지가 다르게 렌더링된다: <br> &emsp; - status 1 → 우는 이모지 <br> &emsp; - status 2 → 잔잔한 미소 이모지 <br> &emsp; - status 3 → 활짝 웃는 이모지 <br><br> **2) 챌린지 화면의 배경 이미지 및 캐릭터 표정 렌더링** <br> - 챌린지 화면 진입 시, 3개의 챌린지에 대한 통합 진행도 점수인 `mooneyStatus`를 백엔드 API를 통해 요청한다. <br> - 해당 수치를 기준으로 다음과 같이 배경 이미지 경로(bgPath)가 결정된다: <br>  - mooneyStatus < 2.4 → 천둥이 치는 어두운 배경 <br>  - 2.4 이상 4.0 미만 → 녹색 들판 배경 <br>  - 4.0 이상 → 꽃밭 배경 <br> - 동시에 캐릭터의 표정 또한 점수에 따라 변하며, 상태가 높을수록 밝은 표정의 캐릭터가 렌더링된다. <br><br> **3) SVG 캐릭터 전역 상태 관리** <br> - 로그인 시, 서버에서 사용자의 현재 활성화된 캐릭터 정보를 API를 통해 수신한다. <br> - 해당 캐릭터 ID는 전역 상태 관리 라이브러리인 `flutter_riverpod`의 상태 객체에 저장된다. <br> - 이후 앱 전반(홈, 챌린지, 프로필 등)에 걸쳐 캐릭터 SVG를 참조할 때, 이 전역 상태를 기준으로 렌더링되며, 각 화면에서 API를 반복 호출할 필요 없이 캐릭터가 즉시 반영된다. <br> - 이 구조는 통일된 UI 유지, 렌더링 최적화, API 호출 최소화 측면에서 중요한 장점을 제공한다. <br><br> **Output** <br> - 홈 화면: 각 챌린지 카드에 해당 상태에 맞는 이모지(우는/보통/웃는 캐릭터 이미지)가 렌더링된다 <br> - 챌린지 화면: 챌린지 진행률에 따라 배경 이미지 및 캐릭터 표정이 갱신된다 <br> - 전체 앱: 로그인 후 전역적으로 SVG 캐릭터가 일관되게 표시되며, 상태 변경 시 자동 반영된다 <br> **[서브모듈 1.4 : 문자/금융 앱 알림 내역 확인 및 파싱]** <br><br> **Input** <br> 사용자 스마트폰에 도착하는 모든 알림 <br><br> **내부 로직** <br> **(1) Android의 NotificationListenerService를 통해 사용자가 받은 모든 알림을 Flutter로 전송** <br> 사용자의 스마트폰에 수신되는 모든 알림은 Android 시스템의 `NotificationListenerService`를 통해 수신된다. 본 프로젝트에서는 Kotlin으로 작성된 `NotificationService` 클래스를 통해 이 기능을 구현하였다. <br> 알림이 수신되면, 해당 알림 객체(`StatusBarNotification`)의 `extras` 필드에서 제목, 내용, 확장 텍스트 등의 정보를 추출하여 `HashMap` 형태의 데이터로 정리한다. 이후 이 데이터를 Flutter 애플리케이션 측으로 전달하기 위해, Android native 코드와 Flutter 간 통신을 위한 `MethodChannel`을 설정한다. <br> 이때 사용하는 방식은 Flutter의 `FlutterEngineCache`에 등록된 엔진 인스턴스를 활용하여, Android → Flutter 방향의 데이터 전송 채널인 `MethodChannel("notification_channel")`을 개설한 후, `invokeMethod("notificationPosted", notificationData)`를 통해 알림 정보를 Flutter 쪽으로 전달하는 구조이다. <br> 이 과정을 통해 사용자가 스마트폰에서 수신한 모든 알림이 실시간으로 Flutter 애플리케이션에 전달될 수 있으며, 이후 Flutter 단에서 해당 알림이 결제 알림인지 여부를 판별하고 추가 처리할 수 있도록 한다. <br> ![스크린샷 2025-05-04 125242](https://github.com/user-attachments/assets/ab18470f-3b9e-44b2-89a4-b139ebbbcaad) <br><br> **(2) 결제내역 관련 문자/어플 알림만 필터링** <br> Android의 `NotificationListenerService`를 통해 전달된 모든 알림은 Flutter 애플리케이션 측에서 `MethodChannel`을 통해 수신된다. 이때 알림 데이터는 JSON-like 형태의 `Map`으로 전달되며, `tickerText`, `title`, `text` 등 주요 필드가 포함된다. <br> Flutter 애플리케이션에서는 `_channel.setMethodCallHandler(...)`를 통해 해당 채널에서 호출되는 메서드를 감지하고 처리한다. 그중 `notificationPosted` 메서드가 호출되면, 전달된 알림의 텍스트 정보(`tickerText`, `text`)를 기반으로 다음 과정을 통해 결제 관련 알림 여부를 판별한다. <br><br>  **1) _transactionKeywords 목록 정의** <br>  결제, 승인, 체크카드, 사용, 출금, 입금, 일시불 등 결제와 관련된 키워드들을 사전에 리스트 형태로 정의한다. <br><br>  **2) 텍스트 내 키워드 포함 여부 검사** <br>  전달된 알림 중 `tickerText`나 `text`에 위 키워드가 하나라도 포함되어 있으면 해당 알림을 결제 알림으로 간주한다. 이때 `.any()` 함수를 이용하여 효율적으로 필터링을 수행한다. <br><br>  **3) TransactionNotification 객체화** <br>  결제 알림으로 판별된 경우에는, 알림 내용을 기반으로 `TransactionNotification` 객체를 생성하여 이후의 파싱 및 API 전송 흐름으로 연결된다. <br><br> 이를 통해 결제와 무관한 광고성/시스템성 알림은 모두 제외하고, 사용자의 금융 거래에 해당하는 알림만을 선별하여 분석 대상으로 삼을 수 있다. <br> 또한, 키워드 기반 필터링 구조이기 때문에 추후 새로운 표현 방식(예: "소액결제 승인", "앱 결제 완료" 등)이 등장할 경우 키워드 리스트만 확장하여 유연하게 대응할 수 있다. <br> 하단에 첨부한 코드는, Flutter로 작성된 `NotificationPlugin` 코드 중 2번에 해당하는 부분만을 캡처한 것이다. <br> ![스크린샷 2025-05-04 130824](https://github.com/user-attachments/assets/cfe39f1d-0e12-4785-9eec-63c8e63a4af4) <br> ![스크린샷 2025-05-04 130526](https://github.com/user-attachments/assets/8c8da560-27f9-4089-8ed7-d7afdb54d411) <br> **(3) 각 알림 내에서 금액, 결제 시각, 결제 수단, 결제처 등의 정보를 정규 표현식을 이용해 파싱** <br> 결제 알림으로 분류된 알림은 `TransactionParser` 클래스를 통해 상세 데이터를 추출한다. 이 클래스는 결제 알림의 `tickerText`와 `text`를 하나의 문자열로 합친 후, 다양한 정규 표현식을 이용하여 금액, 시간, 결제처, 결제 수단 등을 필드로 추출한다. <br> 특히 은행 및 카드사마다 문장 구성 방식이 상이하다는 점을 고려하여, 해당 파싱 로직은 다양한 형태의 문장 구조에 유연하게 대응할 수 있도록 설계되었다. <br> 예를 들어, 동일한 금액이나 결제처 정보라도 카드사에 따라 "이용", "승인", "결제" 등의 표현이 다르게 나타나며, 시간 정보나 결제 수단의 위치 또한 고정되어 있지 않다. <br> 이에 따라 `TransactionParser`는 단일 패턴에만 의존하지 않고, 우선순위가 다른 복수의 정규식 패턴을 조합하여 정보를 추출하고, 예상한 패턴이 실패했을 경우를 대비한 예외 대응(fallback) 로직을 함께 구현하였다. <br> 이러한 구조는 필드 누락, 패턴 불일치와 같은 상황에서도 가능한 범위 내에서 신뢰도 높은 데이터를 추출할 수 있도록 해준다. <br><br> 파싱은 다음과 같은 로직으로 진행된다. <br><br> ① **금액(amount) 추출** <br> - "₩", "원" 등 단위를 포함한 숫자 패턴을 우선 탐색한다 (`\d{1,3}(,\d{3})*원` 등). <br> - 위의 조건에 해당하는 필드가 없을 경우 쉼표만 포함된 숫자 패턴으로 fallback한다. <br> - 추출된 문자열은 단위를 제거하고 숫자로 정제된다. <br><br> ② **결제 시각(transactionTime) 추출** <br> - 알림 내 "03/02 13:52" 형식의 날짜+시간 정보를 정규 표현식으로 추출하고, <br> - `DateFormat`을 활용해 ISO 8601 포맷으로 변환하여 일관된 시간 형식으로 가공한다. <br> - 알림에 시각 정보가 없을 경우, 기본값을 지정한다. <br><br> ③ **결제 수단(transactionSource) 및 알림 출처(sourceApp) 추출** <br> - "체크카드", "출금", "입금" 등의 단어가 포함된 문장을 통해 결제 수단을 파악한다. <br> - "Web발신"이 포함되어 있으면 sms, 아니면 app으로 출처 구분한다. <br><br> ④ **결제처(payee) 추출** <br> - "매장에서 사용"과 같은 구절 앞에 위치한 단어를 기준으로 추출한다. <br> - 정제되지 않은 경우에는 날짜, 시간, 금액, 특수문자 등을 제거하고, 최소 한 글자 이상의 한글 또는 영문이 포함된 단어 중 가장 앞의 단어를 결제처로 추정한다. <br><br> 이러한 구조는 알림 문장이 은행사/카드사마다 다르다는 현실적인 제약을 반영하여 설계된 것이다. 정규표현식 기반 파싱을 여러 단계로 나누고 fallback 로직을 함께 구현함으로써, 다양한 문장 구조에 유연하게 대응할 수 있으며, 불완전한 정보가 포함된 알림에서도 최대한 정확한 데이터를 추출하도록 구현되었다. <br> 이후 Flutter 측에서는 이 `TransactionParser.parseTransaction()` 함수를 호출하여 파싱 결과를 `Map<String, dynamic>` 형태로 받아들이며, 이후 해당 데이터를 API 전송 단계로 넘기도록 구현되어 있다. <br>  ![스크린샷 2025-05-04 131226](https://github.com/user-attachments/assets/691df73f-ea2c-4f5f-8ab6-1d971707f601) <br> ![스크린샷 2025-05-04 131233](https://github.com/user-attachments/assets/666b74cd-ef5c-4008-8273-bcb2bf58b572) <br> ![스크린샷 2025-05-04 131304](https://github.com/user-attachments/assets/0de67d47-05e6-4e85-b0b1-c8d2f622ad7b) <br><br> **Output** <br>아래 형태의 사용자 결제내역 json 객체 반환 <br> { "amount": 0, "transactionTime": "2025-03-01T09:02:26.077Z", "transactionSource": "string", "payee": "string" } <br><br> **2. 모듈2 – Backend (Spring Boot)** <br><br> **\[서브모듈 2.1 절약 챌린지 시스템 모듈]** <br> **\[2.1.1 맞춤 챌린지 자동 생성 모듈]** <br>**1. 예측용 데이터 DB에서 추출 및 AI 전달** <br>**Input**<br>- 매주 일요일 자정, Spring scheduler를 사용해서 자동 챌린지 생성을 위한 트리거 요청<br><br>**내부 로직**<br>사용자의 주간 소비 내역을 카테고리별로 집계 (주 단위 집계)하여 AI 서버 모듈로 전달<br><br>**Output**<br>- FastAPI AI 서버 모듈 /predict에 사용자별 카테고리 주간 소비 내역 전달<br>- 전송 포맷 예시:<br>json { "userId": "2", "data": \[ { "timestamp": "2025-01-01", "expense\_category": "카페", "amount": 5400 }, { "timestamp": "2025-01-01", "expense\_category": "식비", "amount": 20400 } ] }<br><br> **2. 예측 결과 기반 챌린지 생성** <br>**Input**<br>AI 서버에서 받은 \*사용자 유효 카테고리에 대한 다음 주 소비 예측 결과, 사용자의 다음 주 예산 정보<br>\*사용자 유효 카테고리: 사용자가 자주 사용하고, 규칙성이 있어 예측이 유효한 카테고리를 지칭<br><br>**내부 로직**<br>**1. 예산 초과 예상 카테고리 선별**<br>- 조건: 예측 소비금액 > 다음 주 해당 카테고리 예산<br>- 대상 카테고리 리스트에서 랜덤으로 3개 추출<br>- 예외: 예산 초과 항목이 3개 미만일 경우, 가능한 모든 항목에 대해 챌린지 생성<br>**2. 해당 카테고리에서 사용자가 가장 많은 돈을 쓴 상위 3곳과 가장 자주 방문한 상위 3곳 중 하나를 무작위로 선택하여 두 가지 챌린지 생성**<br>**3. 2종류의 챌린지 생성**<br> **1) 방문 제한 챌린지 (visit\_limit)** <br>목표: 방문 횟수 자체를 제한<br>계산: 방문 가능 횟수 = floor((카테고리 예산 × 0.8) / 1회 평균 지출액)<br>조건:<br>- 최소 1회 이상 보장<br>1회 평균 지출액 = (해당 지출처 총 지출) / (해당 지출처 방문 수)<br> **2) 금액 제한 챌린지 (amount\_limit)** <br>목표: 지출 총액을 제한<br>계산: 한도 = max(카테고리 예산 × 0.8, 예측 소비 - 예산)<br>단, 음수 또는 0 이하 한도는 기본값(예: 5000원)으로 보정<br><br> **4. 최종 챌린지 선택** <br>기준: 두 챌린지를 각각 가정하여 적용했을 때 예측 소비와 예산 차이를 줄이는 효과 계산<br>계산 예시:<br>- 방문 제한 챌린지 실행 시 예상 소비 = 평균 지출 × 설정 방문 수<br>- 금액 제한 챌린지 실행 시 예상 소비 = 설정 금액<br>두 챌린지 중 예측 소비와 예산 간 오차가 더 작아지는 쪽을 최종 선택<br><br> **5. 자연어 문장 변환** <br>자연어 템플릿 적용<br>- 방문 제한: {지출처} 방문을 {횟수}회 이하로 줄이기!<br>- 금액 제한: {지출처}에서 이번 주 {금액}원 넘지 않게 소비하기!<br><br> **6. 해당 챌린지의 내용을 자연어로 바꿔 앱 프론트엔드 모듈에 전달** <br><br>**Output**<br>JSON output 예시 <br>```json [ "주식회사 티머니를 1회 이하 소비하기!", "현대백화점신촌을 1회 이하 방문하기!", "보드게임카페를 1회 이하 소비하기!" ] ``` <br><br> **\[2.1.2 챌린지 진행 상태 업데이트 모듈]** <br>사용자의 주간 절약 챌린지(방문 제한형/소비 금액 제한형)에 대한 진행 상태 점수를 실시간으로 계산하고, 프론트엔드에 전달하기 위한 모듈입니다.<br><br>**Input**<br>현재 날짜, \*챌린지별 사용 금액, 챌린지별 목표 (금액/횟수)<br>\*사용 금액 집계: 소비 발생 시 챌린지 해당 여부 확인 및 횟수 증가. 화면 접속 시 상태 재계산 및 API 전달.<br><br>**내부 로직**<br>1. 요일 기준 중간 목표 계산<br>- 현재 요일 기준으로 이번 주 목표 달성률 기대치를 계산함<br>- 계산식:<br>기대비율 = (오늘 - 주 시작일) / 7<br>기대치 = 챌린지 목표값 × 기대비율<br>- 적용 예시:<br>- 월요일: 기대비율 0.14<br>- 수요일: 기대비율 0.43<br>- 금요일: 기대비율 0.71<br><br>2. 챌린지 평가 방식<br>\[A] 방문 제한형 챌린지 (visit\_limit)<br>- 입력 예시: 목표 3회 이하, 현재 방문 1회<br>- 평가 방식:<br>- 현재 방문 수 < 기대 방문 횟수 → 보너스 +1.0<br>- 현재 방문 수 > 기대 방문 횟수 → 감점 -1.0<br>- 예측 방문 수 > 목표 방문 수 → 추가 감점 -0.5<br><br>\[B] 소비 금액 제한형 챌린지 (amount\_limit)<br>- 입력 예시: 목표 15,000원 이하, 현재 사용 9,000원<br>- 평가 방식:<br>- 현재 소비액 < 기대 소비 금액 → 보너스 +1.0<br>- 현재 소비액 > 기대 소비 금액 → 감점 -1.0<br>- 예측 소비액 > 허용 소비액 → 추가 감점 -0.5<br><br>최종 점수 계산<br>- 기준 점수: 3.0 (시작 시 기본값)<br>- 보너스 및 감점 적용 후 보정<br>- 범위 제한: min(max(score, 1.0), 5.0)<br>- 예시:<br>- 기본 3.0점 + 보너스 1.0 → 4.0점<br>- 기본 3.0점 - 감점 1.0 - 예측 감점 0.5 → 1.5점<br><br>**Output**<br>챌린지별 사용자 점수 (float, 1\~5)를 앱 프론트엔드 모듈에 전달<br>전송 포맷 예시:<br>json { "missions": \[ { "title": "티머니개인택시\_0에서 14600원 이하로 소비하기!", "advice": "평균적으로 일주일에 1.0회 지출하고, 지출할 때마다 14,600원 소비해요.\n 이번 주는 14600원 이하로 소비하는 것은 어떨까요?", "result": 5, "numOfExpense": 0, "amountOfExpense": 0 }, { "title": "주식회사 티머니1회 이하 방문하기!", "advice": "평균적으로 일주일에 6.0회 / 9,150원 소비해요.\n 이번 주는 방문횟수를 1회 이하로 줄여볼까요?", "result": 5, "numOfExpense": 0, "amountOfExpense": 0 }, { "title": "(주)현대백화점신촌를 0회 이하 소비하기!", "advice": "평균적으로 일주일에 3.0회 / 13,633원 소비해요.\n 이번 주는 방문횟수를 0회 이하로 줄여볼까요?", "result": 2, "numOfExpense": 0, "amountOfExpense": 0 } ], "mooneystatus": 4.3333335 }<br>

**\[서브 모듈 2.2 똑똑소비봇 모듈]**<br><br>**Input**<br>사용자가 입력한 소비 고민 질문 (현재 두 가지 유형의 사용자 질문에 대해 최적화)<br>(1) "a는 10,000원이고 b는 30,000원인데, 뭘 사는 게 좋을까?"<br>(2) “a를 살까 말까?”<br><br>**내부 로직**<br>사용자가 입력한 질문은 프론트엔드로부터 넘어온다.<br>PostgreSQL DB에서 사용자, 캐릭터 데이터, 사용자가 세운 카테고리 예산별 잔액, 이전 지출 요약 데이터를 꺼내 사용한다.<br>프롬프트는 사용자의 질문을 분석해 어느 카테고리에 대한 소비인지 파악하고, 이전 지출 데이터를 바탕으로 앞으로의 소비를 추론하고, 현재 날짜를 고려해 현시점에 사용하기 적절한 금액을 조언하도록 구성되어있다.<br><br>GPT 응답 생성을 위해 전달되는 데이터:<br>1) 역할 설정: 캐릭터 이름, 성격, 어조 주입<br>2) 상황 설명 및 지침 (사용자의 질문 유형 파악, 카테고리 파악, 향후 예상 소비 추론 진행)<br>3) 사용자의 이름, 질문<br>4) 사용자의 카테고리 예산별 잔액과 이전 지출 요약 데이터<br>5) 오늘 날짜 (진행률 고려)<br>6) OpenAIOption값 (temperature, maxTokens, topP, frequencyPenalty, presencePenalty)<br><br>사용자의 질문과 GPT의 응답에 관한 채팅 데이터는 Redis에 저장된다. 일정기간 이후에 삭제되도록 추가 개발할 계획이다.<br><br>**Output**<br>GPT가 생성한 응답 메시지를 프론트엔드에 전달한다.<br>응답 예시:<br>`json { "response": "화연님, 이번 달 쇼핑 카테고리 예산이 20만 원이네요. 10만 원짜리 옷을 사고 나머지 기간 동안 아껴 쓰면 충분히 조절이 가능해요.\n이전 달 평균을 보니, 쇼핑 카테고리는 한 달에 2회, 회당 약 8만 원 정도 소비하셨네요. 쇼핑 카테고리는 원래 지출이 불규칙하니까, 이번 달 초에 사고 중순 이후엔 최소한으로 지출하면서 맞추는 방식도 괜찮아요. 원하는 걸 적절한 타이밍에 사는 것도 현명한 소비 중 하나니까요! 😊" } `<br>

**\[서브 모듈 2.3 월별리포트 모듈] (현재 개발 진행중)**<br><br>**Input**<br>1) 캐릭터 이름, 성격, 어조<br>2) OpenAIOption값 (temperature, maxTokens, topP, frequencyPenalty, presencePenalty)<br>3) 사용자의 예산 카테고리별 예산과 예산 대비 지출 현황<br><br>**내부 로직**<br>Input을 통해 사용자의 소비 중 예산 준수 여부를 바탕으로 칭찬할 점 2개 선정<br>1-1. 후보 조건<br>- 다음 중 하나 이상 만족하는 항목을 대상으로 함:<br>- 소비 비율 ≤ 80%<br>- 예산을 초과하지 않았고, 절대 지출 금액이 큰 항목<br>1-2. 우선순위 정렬<br>- 절약 비율이 낮을수록(= 더 절약함) 우선<br>- 절약 비율이 같다면, 지출 금액이 높은 순으로 정렬<br>1-3. 상위 2개 항목 선택<br>2. 개선할 항목 2개 선정<br>2-1. 후보 조건<br>- 소비 비율 > 100%인 항목<br>2-2. 우선순위 정렬<br>- 소비 초과 비율이 높은 순<br>- 초과 지출 금액이 큰 순<br>2-3. 상위 2개 항목 선택<br>3. 이를 바탕으로 GPT-4o-mini를 활용한 프롬프트 기반 자연어 피드백 생성 (캐릭터별 말투 및 성격에 맞는 응답 제공)<br>긍정 피드백:<br>- 각 칭찬 항목에 대해 예산 관리의 우수성을 설명<br>- 칭찬 문구 + 유지 전략 또는 동기 부여 제시<br>개선 피드백:<br>- 각 개선 항목에 대해 과소비 사실과 그 영향 설명<br>- 초과 지출 원인에 대한 추정 + 실천 가능한 개선 방안 제안<br>4. 다음 달 실천 팁 도출<br>- 칭찬 항목 → 유지 전략 (예: “현재처럼 외식 횟수를 조절하면 좋겠어요.”)<br>- 개선 항목 → 구체적인 조언 (예: “쇼핑은 ‘3일 보류’ 원칙을 적용해보세요.”)<br>조언은 캐릭터 말투와 성격을 반영하여 자연스럽게 표현<br><br>**Output**<br>자연어 기반 월간 소비 리포트 제공<br>1) 인삿말 및 리포트 도입 문구<br>2) 긍정 피드백 (예: 예산 내 소비, 절약 실천)<br>3) 개선 피드백 (예: 특정 항목 초과 지출)<br>4) 다음 달 예산 관리 팁 및 실천 가능한 조언<br>

**3. 모듈3 – AI 서버 (Python 기반 Prophet 모델)** <br><br> **\[서브모듈 3.1 : 소비 예측 모델]** <br>매주 사용자에게 제공되는 **개인 맞춤형 소비 관리 챌린지**를 위한 핵심 기반 기술로, 사용자별 카테고리 소비 데이터를 바탕으로 **다음 주 예상 소비 금액을 예측**하는 모델입니다. 예측 결과는 절약 챌린지의 대상 카테고리 및 한도를 설정하는 데 활용됩니다.<br><br>**Input**<br>- 사용자별로 주 단위로 집계된 최근 12주 소비 데이터<br>- 형식: JSON 배열 형태로 전달됨<br>- 주요 필드:<br>  - userId: 사용자 식별자<br>  - timestamp: 소비 발생 주차 (ex. 2025-04-07)<br>  - expense\_category: 소비 카테고리명 (ex. 카페, 식비 등)<br>  - amount: 해당 주차의 해당 카테고리 지출 금액<br><br>**내부 로직**<br>1. 데이터 전처리 및 컬럼 정리<br>- JSON 데이터를 Pandas DataFrame으로 변환하고, 컬럼명을 표준화함<br>  - `expense_category` → `item_id`<br>  - `amount` → `target`<br>- `timestamp`는 datetime 형식으로 변환되어 Prophet의 입력 필드인 `ds`로 사용됨<br>2. 예측 가능 카테고리 자동 필터링 (select\_good\_categories)<br>- 다음 조건을 만족하는 카테고리만 선별:<br>  - 최근 6주 이상 연속된 기록 존재<br>  - 표준편차 ≥ 0<br>  - 변동성이 임계치 미만<br>- 사용자가 **자주 사용**하고 **패턴이 일정한 카테고리**만 예측 대상으로 자동 선별<br>3. 이상치 제거 및 보정 (adjust\_outliers)<br>- 시계열 데이터에 포함된 비정상 지출 제거를 위해:<br>  - Z-score 기반 이상치 필터링<br>  - IQR 기반 필터링<br>  - Moving Average로 급등락 완화<br>- Prophet의 민감도를 줄이고 예측 안정성 확보<br>4. 시계열 예측 수행 (run\_prophet)<br>- Prophet 모델로 다음 주 소비 금액 예측<br>- 입력: `ds`, `y`<br>- 설정: 주 단위 seasonality, 비선형 trend, holiday 제외<br>- 예측 결과 `yhat` → 후처리 보정된 `yhat_adjusted` 최종 반환<br>- 내부 실험 기준, 예측 정확도 약 90% 수준<br><br>**Output**<br>예측 결과는 다음 형식으로 반환되며, 사용자의 챌린지 생성 모듈에서 활용됨<br>- Category: 카테고리명 (string)<br>- yhat\_adjusted: 보정된 다음 주 예상 소비 금액 (float)<br>`json { "predict_results": [ { "Category": "카페", "yhat_adjusted": 41200 }, { "Category": "편의점", "yhat_adjusted": 55800 } ] } `<br><br>**사용 기술 및 라이브러리**<br>- fastapi: REST API 서버 구축<br>- uvicorn: FastAPI 실행을 위한 ASGI 서버<br>- pandas: 데이터 전처리 및 주 단위 집계 처리<br>- numpy: 표준편차, 수치 계산 및 배열 연산<br>- prophet: 시계열 예측을 위한 핵심 모델<br>- scikit-learn: Z-score 기반 이상치 탐지 및 통계 분석<br>- scipy: IQR 계산 및 분포 기반 이상치 보정<br><br>

**4. 모듈4 – OpenAI API (외부 모듈)**<br><br>OpenAI API를 서비스의 각 기능에서 호출해 사용하기 위해 다음과 같이 설계했다.<br><br>**캐릭터 개성 반영 프롬프트**<br>GPT가 캐릭터별 성격·어조 정보를 반영하여 피드백을 생성하도록 프롬프트를 구성했다. 본론 영역에는 기능별 지침 텍스트와 사용자 데이터가 삽입된다.<br><br>`text """ 너는 {캐릭터이름}야. {캐릭터성격}의 성격, {캐릭터어조}의 어조를 가진 금융 어시스턴트야. 항상 이 성격과 말투를 유지하며 대답해야 해. 한국어로 대답하고, 마크다운은 절대 사용하지 마. {본론} 이제 {캐릭터이름}의 개성을 반영하여 자연스럽게 답변을 생성해. """ `<br><br>**OpenAI API 주요 파라미터 튜닝**<br>각 기능의 요구사항에 맞춰 응답 스타일을 최적화하기 위해 파라미터를 튜닝했다. Spring AI의 OpenAIOption을 활용해 프리셋을 정의하고 기능 특성에 맞게 사용했다.<br>- 모델: gpt-4o-mini<br>- 프리셋: CREATIVE(창의적), BALANCED(균형), LOGICAL(논리)<br>- 주요 파라미터 및 설명:<br>  - temperature / topP: 창의성 vs. 일관성 균형 조절<br>  - maxTokens: 응답 길이 상한 관리<br>  - frequencyPenalty / presencePenalty: 불필요 반복 억제 또는 강조<br>


|
| (4) 주요 기능의 구현 | **[기능① 맞춤형 챌린지 제공 기능 - 챌린지 진행 상황에 따른 배경 및 캐릭터의 표정 변화 피드백]** <br><br> ![기능① 맞춤형 챌린지 제공 기능 - 챌린지 진행 상황에 따른 배경 및 캐릭터의 표정 변화 피드백](https://github.com/user-attachments/assets/0bde6074-7137-4566-a86d-720efc0e87c6) <br> <기능 개요> <br> 본 기능은 사용자의 누적 소비 데이터를 시계열 AI 모델로 분석하고, 다음 주 과소비가 예상되는 카테고리에 대해 맞춤형 챌린지를 제공한다. 챌린지는 사용자가 자주 소비하거나 누적 지출이 큰 지출처를 구체적으로 언급하며 해당 지출처의 소비를 줄이도록 제안한다. 예를 들어, 사용자의 주요 소비처가 스타벅스 커피숍일 경우, "스타벅스 3회 이하 방문"과 같은 챌린지가 제안된다. 사용자의 챌린지 이행 상황에 따라 캐릭터의 표정 및 배경 등 그래픽 요소가 동적으로 변경되며 피드백 효과를 제공한다. <br><br> <작동 방식 - (1) 챌린지 생성><br>1. Backend 서버 모듈: Backend 서버는 Spring Scheduler를 통해 주기적으로 사용자 맞춤형 챌린지를 자동 생성하기 위해 스케줄링되어있다. AI 서버에게 분석을 위한 요청을 보낸다.<br>2. AI 서버 모듈: FastAPI 기반의 AI 서버는 Prophet 시계열 예측 모델을 사용하여 사용자의 소비 패턴을 분석한다. 과소비가 예측되는 카테고리를 식별하고, 분석 결과는 Backend 서버로 전달된다.<br>3. Backend 서버 모듈:  서버로부터 수신한 과소비 예측 카테고리 결과를 활용해 해당 카테고리의 주요 지출처를 분석하고, 사용자 맞춤형 챌린지를 생성한다. <br>4. Frontend 모듈: 월요일 이후 첫 접속시마다 새로 생성된 이번주의 챌린지 리스트를 표시한다. <br><br> <작동 방식 - (2) 챌린지 진행 상황 확인 및 업데이트> <br>1. Frontend 모듈: 사용자가 매주 수행해야 할 3개의 챌린지를 카드 형태로 표시한다. 사용자가 챌린지를 수행함에 따라 캐릭터의 표정, 배경, 이모지 등 시각적 피드백이 실시간으로 반영된다. 이로써 사용자는 챌린지 진행 상황에 따라 직관적으로 동기를 부여받을 수 있다.<br>2. Backend 서버 모듈: Frontend에게 챌린지 별 이행률과 그래픽 요소 변경을 위한 정보를 전달한다. 실시간으로 사용자의 소비 기록을 바탕으로 챌린지 이행률을 계산하고, 해당 데이터를 데이터베이스에 갱신한다. 또한 사용자별 챌린지 히스토리를 관리한다. <br><br> <작동 방식 - (3) 챌린지 결과 확인><br>1. Frontend 모듈: 한 주가 끝나고 나면, 챌린지 결과 화면을 통해 경험치 등 챌린지의 결과로 얻은 보상을 보여준다. <br>2. Backend 서버 모듈: 예산 이내로 소비를 성공한 정도를 계산하여 경험치를 제공한다.<br><br><br> **[기능② 똑똣소비봇 기능]** <br><br> ![기능② 똑똣소비봇 기능](https://github.com/user-attachments/assets/4059fe62-7acc-4923-9b2e-2d90c3e7e0ff) <br> <기능 개요> <br> 챗봇 형식의 인터페이스에서 사용자가 "이거 사도 돼?" 또는 "A와 B 중 무엇을 살까?"와 같은 질문을 입력하면, 현재 예산 상황과 지출 경향을 종합적으로 분석하여 소비 판단에 대한 조언을 제공하는 기능이다. 현재 적용 중인 캐릭터의 성격 및 말투가 반영된 피드백이 제공된다. <br><br> <작동 방식> <br> 1.  Frontend 모듈: 똑똑소비봇 화면 진입 시, 안내 문구를 통해 해당 기능의 사용 방식을 안내한다. 이후 사용자가 하단의 입력창에 자연어 형식의 질문을 입력하면(ex. A는 10000원이고 B는 30000원인데, B를 사도 될까? 아니면 A를 사야할까), 질문 내용을 API로 전송함과 동시에 똑똑소비봇 결과 화면으로 이동한다. 결과 화면에서 API 응답을 기다리는 동안은 로딩스피너를 통해 결과를 기다리는 중임을 표시하고, API 응답이 오면 응답 내용을 화면에 렌더링한다. <br> 2. Backend 서버 모듈: 사용자의 질문과 함께, 예산 카테고리별 남은 금액 현황, 남은 기간 등의 정보, 조언 방법에 대한 프롬프트, 캐릭터 관련 프롬프트, 그리고 Temperature 등 설정값을 OpenAI API 모듈로 전달한다. 응답 결과를 수신하면 이를 클라이언트에 반환한다. 요청과 응답 데이터는 Redis에 저장한다.<br> 3. OpenAI API 모듈: Backend의 요청 메시지를 확인하고 프롬프트에 따라 사용자의 질문 유형이 A와 B 중 무엇을 살지 고민하는 질문인지, A를 살지 말지 고민하는 질문인지를 판단한 뒤 입력된 정보들을 종합 분석한 후 캐릭터의 성격이 적용된 피드백 메시지를 생성하여 Backend에 반환한다. <br><br> <응답 예시> <br> "OO님, 현재 2월 셋째 주인데 식비 예산은 10만 원 남아있어요. 고민하시는 고기(2만 원)를 드시면 바로 오늘 하루에 예산의 20%를 쓰게 되는 셈이에요. 다음 주(마지막 주)까지 남은 기간이 긴 걸 고려하면, 하루 식사로 지출하기엔 조금 부담스러울 수 있어요. 컵밥(3천 원)을 선택하시면 이번 주 예산에도 여유가 생기고, 다음 주 예상 식비 지출(적어도 4~5만 원 이상 예상)에 대한 부담도 훨씬 줄어들 거예요. 오늘은 조금 아껴서 컵밥으로 드시고, 고기는 다음에 조금 더 여유 있을 때 드시면 더 맛있고 기분 좋게 드실 수 있을 거라 생각해요!😊"<br><br><br> **[기능③ 월별 리포트 기능]** <br><br><img width="1556" alt="기능③ 월별 리포트 기능" src="https://github.com/user-attachments/assets/bb3a9fba-91db-4441-b997-91d9253b910e" /> <br><기능 개요><br>가계부의 분석 탭에서는 사용자의 월간 소비 내역과 예산 데이터를 기반으로 분석을 제공한다. 단순한 수치 요약을 넘어서, 개인화된 자연어 피드백, 주요 소비 내역 하이라이트, 카테고리별 지출 분석, 예산 관리 조언 등을 종합적으로 포함하며, 사용자가 자신의 소비 습관을 직관적으로 이해하고 스스로 개선할 수 있도록 유도한다.<br>특히 월별 리포트는 캐릭터가 사용자 소비 습관을 직접 피드백하는 형태로 구성되어, 데이터 분석 결과를 친숙한 말투로 전달함으로써 사용자의 몰입감을 높이고 반복 사용을 유도한다. 자연어 피드백은 정량적 분석에 기반하되, 이를 사용자가 쉽게 받아들일 수 있는 정성적 해석으로 재구성한다. 캐릭터는 잘한 점과 개선할 점을 균형 있게 제시하며, 무조건적인 경고가 아닌 실천 가능한 대안을 함께 안내한다. 예를 들어, 예산을 잘 관리한 사용자는 칭찬을 통해 동기를 부여받고, 초과 지출이 발생한 경우에는 다음 달 실천 가능한 전략을 제안받는다. 이러한 설계는 사용자의 감정적 저항을 줄이는 동시에 실제 행동 변화를 유도하며, 단순한 정보 전달을 넘어 데이터 기반 소비 코칭의 역할을 수행한다. 결과적으로 본 기능은 숫자 중심의 기존 가계부 서비스와 차별화되는 핵심 기능이다.<br><br> <작동 방식> <br>1. Frontend 모듈: 클라이언트는 월말이 되면, 서버로부터 생성된 리포트 데이터를 가계부의 분석탭 하단의 '무니의 피드백' 컴포넌트를 통해 사용자에게 제공한다. 해당 컴포넌트는 월말 기간 외에는 '무니의 피드백은 월말에 도착해요!' 라는 설명 텍스트를 렌더링한다. <br>2. Backend 서버 모듈: 백엔드 서버는 이번 달의 예산 카테고리별 사용 현황 및 초과한 정도 통계값을 계산하여 캐릭터 프롬프트와 함께 OpenAI API 모듈에 전달한다.<br>3. OpenAI API 모듈: Backend의 요청 메시지를 바탕으로, 캐릭터의 성격이 적용된 피드백 메시지를 생성한 후 Backend에 반환한다.<br><br><구성 요소><br>1) 인삿말 및 리포트 도입 문구<br>"이번 달 소비를 분석해보니, 몇 가지 눈에 띄는 점이 있었어요"와 같이 사용자가 부담 없이 리포트를 받아들이도록 도입부 문구를 제공한다.<br>2) 잘한 점 (긍정 피드백)<br>예: "🎉 저축 목표 달성" / "👍 문화·여가비 절약"<br>분석된 소비 패턴에서 계획적이거나 바람직한 지출 습관이 발견될 경우 이를 구체적인 문장으로 칭찬한다. 금액 기준이 아닌 행동의 질적 측면을 강조하는 점이 특징이다.<br>3) 개선할 점 (부정 피드백)<br>예: "❗ 식비 예산 초과", "❗ 쇼핑 지출 증가"<br>비계획적 소비나 특정 카테고리의 과잉 지출이 감지될 경우, 이에 대한 개선 방향을 자연스럽게 제안한다.수치 언급 없이 사용자가 받아들이기 쉬운 어휘를 활용한다.<br>4) 예산 준수를 위한 팁<br>예: "장보기 목록을 미리 계획해 보세요!", "여유 자금을 저축하면 좋아요"<br>다음 달 예산 관리를 위한 실천 가능한 조언을 제공하며, 개선 피드백과 연결된다. 단순 경고가 아니라 구체적인 대안 제시에 중점을 둔다.<br> |
| (5) 기타 |   |
